<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>高精度加减乘除法</title>
    <url>/2022/01/08/AddDouble//</url>
    <content><![CDATA[<h2 id="题目连接"><a href="#题目连接" class="headerlink" title="题目连接"></a><a href="https://www.luogu.com.cn/problem/P1601">题目连接</a></h2><p><strong>A+B:</strong><br><strong>题目描述</strong><br>高精度加法，相当于a+b problem，不用考虑负数.</p>
<p><strong>输入格式</strong><br>分两行输入。a,b \leq 10^{500}a,b≤10<br>500</p>
<p><strong>输出格式</strong><br>输出只有一行，代表a+ba+b的值</p>
<p><strong>输入输出样例</strong><br><strong>输入 #1</strong></p>
<blockquote>
<p>1<br>1</p>
</blockquote>
<p><strong>输出 #1</strong></p>
<blockquote>
<p>2</p>
</blockquote>
<p><strong>输入 #2</strong></p>
<blockquote>
<p>1001<br>9099</p>
</blockquote>
<p><strong>输出 #2</strong></p>
<blockquote>
<p>10100</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">add</span><span class="params">(string a,string b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>())  <span class="keyword">return</span> <span class="built_in">add</span>(b,a);</span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>,j=b.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        t+=a[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=<span class="number">0</span>) t+=b[j--]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(t%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        t/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t)   res.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(a,b) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><a href="https://www.luogu.com.cn/problem/P2142">题目链接</a><br><strong>A-B:</strong><br><strong>题目描述</strong><br>高精度减法。</p>
<p><strong>输入格式</strong><br>两个整数 a,ba,b（第二个可能比第一个大）。</p>
<p><strong>输出格式</strong><br>结果（是负数要输出负号）。</p>
<p><strong>输入输出样</strong><br><strong>输入</strong><br>2<br>1<br><strong>输出</strong><br>1<br><strong>说明/提示</strong><br>20%20% 数据 a,ba,b 在 long long 范围内；<br>100%100% 数据 0&lt;a,b\le 10^{10086}0&lt;a,b≤10<br>10086<br> 。<br> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(string a, string b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>()!=b.<span class="built_in">size</span>()) <span class="keyword">return</span> a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=b[i]) <span class="keyword">return</span> a[i]&lt;b[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">sub</span><span class="params">(string a,string b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(a,b))&#123;</span><br><span class="line">        flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t =<span class="number">0</span>;</span><br><span class="line">    string res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>,j=b.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        t+=a[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=<span class="number">0</span>) t-=b[j--]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>((t+<span class="number">10</span>)%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        t=t&lt;<span class="number">0</span>?<span class="number">-1</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(res.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp; res.<span class="built_in">back</span>()==<span class="string">&#x27;0&#x27;</span>) res.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(flag)    <span class="keyword">return</span> <span class="string">&quot;-&quot;</span>+res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">sub</span>(a,b) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><a href="https://www.luogu.com.cn/problem/P1480">题目链接</a><br><strong>A/B:</strong></p>
<p><strong>题目描述</strong><br>输入两个整数 a,ba,b，输出它们的商。</p>
<p><strong>输入格式</strong><br>两行，第一行是被除数，第二行是除数。</p>
<p><strong>输出格式</strong><br>一行，商的整数部分。</p>
<p><strong>输入输出样例</strong><br><strong>输入</strong> #1复制<br>10<br>2<br><strong>输出</strong> #1复制<br>5<br><strong>说明/提示</strong><br>0\le a\le 10^{5000}0≤a≤10<br>5000<br> ，1\le b\le 10^91≤b≤10<br>9<br> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">div</span><span class="params">(string a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="string">&quot;0&quot;</span>)  <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    string res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        t=t*<span class="number">10</span>+(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        res.<span class="built_in">push_back</span>(t/b+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        t%=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span>(res.<span class="built_in">size</span>()&gt;<span class="number">1</span> &amp;&amp; res.<span class="built_in">back</span>()==<span class="string">&#x27;0&#x27;</span>) res.<span class="built_in">pop_back</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">div</span>(a,b) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程bin函数</title>
    <url>/2021/12/20/Bin//</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt; /* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>sockfd：</strong><br>    socket文件描述符<br><strong>addr:</strong><br>    构造出IP地址加端口号<br><strong>addrlen:</strong><br>    sizeof(addr)长度<br>返回值：<br>    成功返回0，失败返回-1, 设置errno</p>
</blockquote>
<p>*<em>服务器程序所监听的网络地址和端口号通常是固定不变的，客户端程序得知服务器程序的地址和端口号后就可以向服务器发起连接，因此服务器需要调用bind绑定一个固定的网络地址和端口号。<br>bind()的作用是将参数sockfd和addr绑定在一起，使sockfd这个用于网络通讯的文件描述符监听addr所描述的地址和端口号。前面讲过，struct sockaddr <em>是一个通用指针类型，addr参数实际上可以接受多种协议的sockaddr结构体，而它们的长度各不相同，所以需要第三个参数addrlen指定结构体的长度。</em></em></p>
<h3 id="列"><a href="#列" class="headerlink" title="列:"></a>列:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct sockaddr_in servaddr;</span><br><span class="line">bzero(&amp;servaddr, sizeof(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">servaddr.sin_port = htons(6666);</span><br></pre></td></tr></table></figure>
<p><strong>首先将整个结构体清零，然后设置地址类型为AF_INET，网络地址为INADDR_ANY，这个宏表示本地的任意IP地址，因为服务器可能有多个网卡，每个网卡也可能绑定多个IP地址，这样设置可以在所有的IP地址上监听，直到与某个客户端建立了连接时才确定下来到底用哪个IP地址，端口号为6666。</strong></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>函数模板与类模板</title>
    <url>/2021/12/11/FunctionClassTemplate//</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>C++提供了模板(template)编程的概念。所谓模板，实际上是建立一个通用函数或类，其类内部的类型和函数的形参类型不具体指定，用一个虚拟的类型来代表。这种通用的方式称为模板。模板是泛型编程的基础,泛型编程即以一种独立于任何特定类型的方式编写代码。</strong></p>
<hr>
<hr>
<p><strong>为什么要使用函数模板</strong></p>
<p><font color=#999AAA >这里用返回两数最大值做示列</p>
<p><strong>使用一个函数用来实现多个函数返回两个数的最大值,要求支持多种类型变量</strong></p>
<h1 id="一、函数模板语法与定义"><a href="#一、函数模板语法与定义" class="headerlink" title="一、函数模板语法与定义"></a>一、函数模板语法与定义</h1><p><font color="#dd00dd">所谓函数模板，实际上是建立一个通用函数，其函数类型和形参类型不具体指定，用一个虚拟的类型来代表。这个通用函数就称为函数模板。</font><br /><br><em>凡是函数体相同的函数都可以用这个模板来代替，不必定义多个函数，只需在模板中定义一次即可。在调用函数时系统会根据实参的类型来取代模板中的虚拟类型，从而实现了不同函数的功能。</em></p>
<p><strong>函数模板定义形式</strong><br>  <strong>由以下三部分组成：</strong>  <font color="#dd0000">模板说明 + 函数定义 + 函数模板调用</font><br /> </p>
<p>  <strong>template</strong>   &lt; <font color="#dd0000">类型形式参数表</font>&gt; </p>
<p>  类型   <font color="#00dd00">函数名</font> (形式参数表)<br>{<br>    <strong>//语句序列</strong><br>}</p>
<p><strong>1. 模板说明<br>template</strong>    &lt; <font color="#dd0000">类型形式参数表</font>&gt;<br>类型形式参数的形式：<br>            <strong>typename</strong> T1 ,  <strong>typename</strong> T2 , …… , <strong>typename</strong> Tn<br>或    <strong>class</strong> T1 ,  <strong>class</strong> T2 , …… , <strong>class</strong> Tn </p>
<p><strong>(注：<font color="#dd0000">typename 和 class 的效果完全等同</font>)</strong></p>
<ol start="2">
<li><strong>函数定义</strong><br>类型  <font color="#00dd00">函数名</font> (形式参数表)<br>{<br>}</li>
</ol>
<p><strong>注意:</strong> <font color="#dd0000">模板说明的类属参数必须在函数定义中出现一次<br>      函数参数表中可以使用类属类型参数，也可以使用一般类型参数</font></p>
<ol start="3">
<li><strong>函数模板调用</strong><br><font color="#00dd00">函数名</font><strong>&lt;类型&gt;(</strong> 变量a, 变量b <strong>);</strong>     <strong>//显式类型调用</strong><br><font color="#00dd00">函数名</font><strong>(a, b);   //自动数据类型推导</strong></li>
</ol>
<p>4.<strong>模板函数示列:</strong></p>
<p><img src="https://img-blog.csdnimg.cn/4e87697afc4540f987586e444c9b1f07.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MTQwMTkz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="二、函数模板与重载函数"><a href="#二、函数模板与重载函数" class="headerlink" title="二、函数模板与重载函数"></a>二、函数模板与重载函数</h1><p><font color=#999AAA >思考一下:<br> <font color=#999AAA >1. 如果有函数模板和重载函数，编译器将会调用什么？<br> <font color=#999AAA >2.不存在普通函数，函数模板会隐式数据类型转换吗？</p>
<h2 id="1-问题1"><a href="#1-问题1" class="headerlink" title="1.问题1"></a>1.问题1</h2><p><font color=#999AAA >代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T &amp;a, T &amp;b)</span></span>&#123;</span><br><span class="line">	T t;</span><br><span class="line">	t = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = t;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;Swap 模板函数被调用了&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">char</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>  t;</span><br><span class="line">	t = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = t;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;Swap 普通函数被调用了&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> cNum = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">	<span class="keyword">int</span> iNum = <span class="number">65</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">Swap</span>(cNum, iNum);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>结论:</strong> 第一种情况,模板函数和普通函数并存,参数类型和普通重载函数更匹配将会<font color="#dd0000">调用普通函数</font><br /> </p>
<h2 id="2-问题2"><a href="#2-问题2" class="headerlink" title="2.问题2"></a>2.问题2</h2><p><font color=#999AAA >代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T &amp;a, T &amp;b)</span></span>&#123;</span><br><span class="line">	T t;</span><br><span class="line">	t = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = t;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;Swap 模板函数被调用了&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> cNum = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">	<span class="keyword">int</span> iNum = <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Swap</span>(cNum, iNum);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结论:</strong> 第二种情况  不存在普通函数，函数模板会隐式数据类型转换嘛？<br><font color="#dd0000">不提供隐式的数据类型转换,必须是严格的匹配</font><br /> </p>
<hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1">


<h1 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p><font color=#999AAA ><strong>为什么需要类模板<br>类模板与函数模板的定义和使用类似，有时，有两个或多个类，其功能是相同的，仅仅是数据类型不同</strong></p>
<p><font color=#999AAA > 代码示列:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(T t)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;t = t;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">T &amp;<span class="title">getT</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>得出结论:</strong><br><font color=#999AAA ><strong>类模板用于实现类所需数据的类型参数化</strong><br><strong>类模板在表示支持多种数据结构显得特别重要，这些数据结构的表示和算法不受所包含的元素类型的影响</strong></p>
<h1 id="类模板定义"><a href="#类模板定义" class="headerlink" title="类模板定义"></a>类模板定义</h1><p>   <strong>类模板由模板说明和类说明构成模板说明同函数模板，如下：</strong></p>
<p>   <strong>template</strong>    &lt;<font color="#dd0000">类型形式参数表</font>&gt;<br>         <strong>类声明</strong></p>
<p><font color=#999AAA > 代码示列:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>  &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> ：</span><br><span class="line">   Type DataMember;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模板类的使用"><a href="#模板类的使用" class="headerlink" title="模板类的使用"></a>模板类的使用</h2><p><font color=#999AAA > 代码示列:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	//函数的参数列表使用虚拟类型</span><br><span class="line">	A(T t=0)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;t = t;</span><br><span class="line">	&#125;</span><br><span class="line">	//成员函数返回值使用虚拟类型</span><br><span class="line">	T &amp;getT()</span><br><span class="line">	&#123;</span><br><span class="line">		return t;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	//成员变量使用虚拟类型</span><br><span class="line">	T t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void printA(A&lt;int&gt; &amp;a)&#123;</span><br><span class="line">	cout&lt;&lt;a.getT()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">	A&lt;int&gt;  a(666);</span><br><span class="line">	cout&lt;&lt;a.getT()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	//模板类做为函数参数</span><br><span class="line">	printA(a);</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>得出结论:</strong> </p>
<ol>
<li><font color="#dd0000">类模板定义对象,必须显示指定类型</font></li>
<li><font color="#dd0000">模板种如果使用了构造函数，则遵守以前的类的构造函数的调用规则</font></li>
</ol>
<h1 id="继承中类模板怎么使用"><a href="#继承中类模板怎么使用" class="headerlink" title="继承中类模板怎么使用"></a>继承中类模板怎么使用</h1><p><font color=#999AAA >首先思考<br><font color=#999AAA > 1. 父类一般类，子类是模板类<br> 2. 子类是一般类，父类是模板类<br> 3. 父类和子类都时模板类时</p>
<h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><p><font color=#999AAA >代码示列:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	B(int b)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;b = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	int b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class A:public B</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	//函数的参数列表使用虚拟类型</span><br><span class="line">	A(T t):B(0)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;t = t;</span><br><span class="line">	&#125;</span><br><span class="line">	//成员函数返回值使用虚拟类型</span><br><span class="line">	T &amp;getT()</span><br><span class="line">	&#123;</span><br><span class="line">		return t;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	//成员变量使用虚拟类型</span><br><span class="line">	T t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="问题1结论"><a href="#问题1结论" class="headerlink" title="问题1结论"></a>问题1结论</h3><p> <font color="#dd0000">父亲一般类,子类是模板类,和普通继承的玩法类似</font></p>
<h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><p><font color=#999AAA >代码示列:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	//函数的参数列表使用虚拟类型</span><br><span class="line">	A(T t)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;t = t;</span><br><span class="line">	&#125;</span><br><span class="line">	//成员函数返回值使用虚拟类型</span><br><span class="line">	T &amp;getT()</span><br><span class="line">	&#123;</span><br><span class="line">		return t;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	//成员变量使用虚拟类型</span><br><span class="line">	T t;</span><br><span class="line">&#125;;</span><br><span class="line">						//需具体化模板</span><br><span class="line">class B : public A&lt;int&gt;	//A&lt;int&gt;参数列表初始化</span><br><span class="line">&#123;</span><br><span class="line">public:					//需具体化模板</span><br><span class="line">	B(Tb b) :A&lt;int&gt;(b)	//初始化父类</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;b = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	int b;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="问题2结论"><a href="#问题2结论" class="headerlink" title="问题2结论"></a>问题2结论</h3><p> <font color="#dd0000">子类是一般类，父类是模板类,继承时必须在子类里实例化父类的类型参数</font></p>
<h2 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h2><p><font color=#999AAA >代码示列:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	//函数的参数列表使用虚拟类型</span><br><span class="line">	A(T t)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;t = t;</span><br><span class="line">	&#125;</span><br><span class="line">	//成员函数返回值使用虚拟类型</span><br><span class="line">	T &amp;getT()</span><br><span class="line">	&#123;</span><br><span class="line">		return t;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	//成员变量使用虚拟类型</span><br><span class="line">	T t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename Tb&gt;</span><br><span class="line">class B: public A&lt;int&gt;</span><br><span class="line">&#123;</span><br><span class="line">	public:</span><br><span class="line">	B(Tb b):A&lt;Tb&gt;(b)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;b = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	Tb b;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void printA(A&lt;int&gt; &amp;a)&#123;</span><br><span class="line">	cout&lt;&lt;a.getT()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">	//1.模板类定义类对象，必须显示指定类型</span><br><span class="line">	//2.模板种如果使用了构造函数，则遵守以前的类的构造函数的调用规则</span><br><span class="line">	A&lt;int&gt;  a(666);</span><br><span class="line">	cout&lt;&lt;a.getT()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	B&lt;int&gt; b(888);</span><br><span class="line">	cout&lt;&lt;&quot;b(888): &quot;&lt;&lt;b.getT()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	//模板类做为函数参数</span><br><span class="line">	printA(a);</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="问题3结论"><a href="#问题3结论" class="headerlink" title="问题3结论"></a>问题3结论</h3><p> <font color="#dd0000">父类和子类都时模板类时，子类的虚拟的类型可以传递到父类中<br></font></p>
<h1 id="类模板的四种写法"><a href="#类模板的四种写法" class="headerlink" title="类模板的四种写法"></a>类模板的四种写法</h1><p><font color=#999AAA >上边的代码都是类内写的，列如文件分离的情况下，怎么写出类模板函数</p>
<h2 id="第一种情况在cpp文件类内部"><a href="#第一种情况在cpp文件类内部" class="headerlink" title="第一种情况在cpp文件类内部"></a>第一种情况在cpp文件类内部</h2><p><font color=#999AAA > 上面代码已实现,已讲解</p>
<h3 id="第二种情况在cpp文件类外部"><a href="#第二种情况在cpp文件类外部" class="headerlink" title="第二种情况在cpp文件类外部"></a>第二种情况在cpp文件类外部</h3><p><font color=#999AAA >代码示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	A(T t=0);</span><br><span class="line"></span><br><span class="line">	T &amp;getT();</span><br><span class="line"></span><br><span class="line">	A operator +(const A &amp;other);</span><br><span class="line"></span><br><span class="line">	void print();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	T t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//需声明类型,告诉编译器将进行泛型编程</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">A&lt;T&gt;::A(T t)</span><br><span class="line">&#123;</span><br><span class="line">		this-&gt;t = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//需声明类型,告诉编译器将进行泛型编程</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">T &amp;A&lt;T&gt;::getT()</span><br><span class="line">	&#123;</span><br><span class="line">		return t;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">//需声明类型,告诉编译器将进行泛型编程</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">A&lt;T&gt; A&lt;T&gt;::operator+(const A&lt;T&gt; &amp;other)&#123;</span><br><span class="line">		A&lt;T&gt; tmp; //类的内部类型可以显示声明也可以不显示</span><br><span class="line">		tmp.t =this-&gt;t + other.t;</span><br><span class="line">		return tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">//需声明类型,告诉编译器将进行泛型编程</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void A&lt;T&gt;::print()&#123;</span><br><span class="line">	cout&lt;&lt;this-&gt;t&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">	</span><br><span class="line">	A&lt;int&gt;  a(666), b(888);</span><br><span class="line"></span><br><span class="line">	A&lt;int&gt; tmp = a + b;</span><br><span class="line"></span><br><span class="line">	tmp.print();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第三种情况文件分离"><a href="#第三种情况文件分离" class="headerlink" title="第三种情况文件分离"></a>第三种情况文件分离</h4><p><font color=#999AAA >代码示例:<br>.h文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	A(T t=0);</span><br><span class="line"></span><br><span class="line">	T &amp;getT();</span><br><span class="line"></span><br><span class="line">	A operator +(const A &amp;other);</span><br><span class="line"></span><br><span class="line">	void print();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	T t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><font color=#999AAA >.cpp文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;demo.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//需声明类型,告诉编译器将进行泛型编程</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">A&lt;T&gt;::A(T t)</span><br><span class="line">&#123;</span><br><span class="line">		this-&gt;t = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//需声明类型,告诉编译器将进行泛型编程</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">T &amp;A&lt;T&gt;::getT()</span><br><span class="line">	&#123;</span><br><span class="line">		return t;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//需声明类型,告诉编译器将进行泛型编程</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">A&lt;T&gt; A&lt;T&gt;::operator+(const A&lt;T&gt; &amp;other)&#123;</span><br><span class="line">		A&lt;T&gt; tmp; //类的内部类型可以显示声明也可以不显示</span><br><span class="line">		tmp.t =this-&gt;t + other.t;</span><br><span class="line">		return tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//需声明类型,告诉编译器将进行泛型编程</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void A&lt;T&gt;::print()&#123;</span><br><span class="line">	cout&lt;&lt;this-&gt;t&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">	</span><br><span class="line">	A&lt;int&gt;  a(666), b(888);</span><br><span class="line"></span><br><span class="line">	A&lt;int&gt; tmp = a + b;</span><br><span class="line"></span><br><span class="line">	tmp.print();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="第四种情况main函数分离"><a href="#第四种情况main函数分离" class="headerlink" title="第四种情况main函数分离"></a>第四种情况main函数分离</h5><p><font color=#999AAA >main函数是独立.cpp文件时:</p>
<p><font color=#999AAA >main函数代码示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> cout &lt;&lt; &quot;示例:这样运行会直接报错，无法解析的外部符号&quot; &lt;&lt; endl;</span><br><span class="line">/*</span><br><span class="line">int main(void)&#123;</span><br><span class="line">	</span><br><span class="line">	A&lt;int&gt;  a(666), b(888);</span><br><span class="line"></span><br><span class="line">	A&lt;int&gt; tmp = a + b;</span><br><span class="line"></span><br><span class="line">	tmp.print();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;*/</span><br></pre></td></tr></table></figure>
<p><font color="#dd0000"> 解决方案: </font> <strong>需要包含类模板实现的</strong> <font color="#dd0000"> .cpp</font><strong>文件</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><font color=#999AAA >在第二种情况需注意：</p>
<p><strong>在同一个cpp 文件中把模板类的成员函数放到类的外部，需要注意以下几点</strong></p>
<p>函数前声明 <strong>template</strong>    &lt;<font color="#dd0000">类型形式参数表</font>&gt;<br><em><strong>类的成员函数前的类限定域说明必须要带上虚拟参数列表</strong></em><br><em><strong>返回的变量是模板类的对象时必须带上虚拟参数列表<br>成员函数参数中出现模板类的对象时必须带上虚拟参数列表<br>成员函数内部没有限定</strong></em></p>
<p><font color=#999AAA >在第三种情况需注意：</p>
<p><font color="#dd0000">注意:</font><strong>当类模板的声明(<font color="#dd0000">.h文件</font>)和实现(<font color="#dd0000">.cpp 或.hpp文件</font>)完全分离，因为类模板的特殊实现，我们应在使用类模板时使用<font color="#dd0000">#include</font> 包含 实现部分的<font color="#dd0000">.cpp 或.hpp文件</font>。</strong></p>
<h1 id="特殊情况-类模板与友元函数"><a href="#特殊情况-类模板与友元函数" class="headerlink" title="特殊情况!!!  类模板与友元函数"></a>特殊情况!!!  类模板与友元函数</h1><p><font color=#999AAA >代码示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	A(T t=0);</span><br><span class="line"></span><br><span class="line">	//声明一个友元函数，实现对两个A类对象进行加法操作</span><br><span class="line">	template &lt;typename T&gt;</span><br><span class="line">	friend A&lt;T&gt; addA(const A&lt;T&gt; &amp;a, const A&lt;T&gt; &amp;b);</span><br><span class="line"></span><br><span class="line">	T &amp;getT();</span><br><span class="line"></span><br><span class="line">	A operator +(const A &amp;other);</span><br><span class="line"></span><br><span class="line">	void print();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	T t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">A&lt;T&gt;::A(T t)</span><br><span class="line">&#123;</span><br><span class="line">		this-&gt;t = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">T &amp;A&lt;T&gt;::getT()</span><br><span class="line">	&#123;</span><br><span class="line">		return t;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">A&lt;T&gt; A&lt;T&gt;::operator+(const A&lt;T&gt; &amp;other)&#123;</span><br><span class="line">		A tmp; //类的内部类型可以显示声明也可以不显示</span><br><span class="line">		tmp.t =this-&gt;t + other.t;</span><br><span class="line">		return tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void A&lt;T&gt;::print()&#123;</span><br><span class="line">	cout&lt;&lt;this-&gt;t&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//A 类的友元函数,就是它的好朋友</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">A&lt;T&gt; addA(const A&lt;T&gt; &amp;a, const A&lt;T&gt; &amp;b)&#123;</span><br><span class="line">	A&lt;T&gt; tmp;</span><br><span class="line">	cout&lt;&lt;&quot;call addA()...&quot;&lt;&lt;endl;</span><br><span class="line">	tmp.t = a.t + b.t;</span><br><span class="line">	return tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">	</span><br><span class="line">	A&lt;int&gt;  a(666), b(888);</span><br><span class="line"></span><br><span class="line">	A&lt;int&gt; tmp = a + b;</span><br><span class="line">	A&lt;int&gt; tmp1 = addA&lt;int&gt;(a, b);</span><br><span class="line">	</span><br><span class="line">	tmp.print();</span><br><span class="line">	tmp1.print();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类模板友元结论"><a href="#类模板友元结论" class="headerlink" title="类模板友元结论"></a>类模板友元结论</h2><ol>
<li><em><strong>类内部声明友元函数，必须写成一下形式</strong></em><br> template&lt;typename <font color="#dd0000">T</font>&gt;</li>
</ol>
<p><strong>friend</strong> A &lt;<font color="#dd0000">T</font>&gt; addA (A&lt;<font color="#dd0000">T</font>&gt; &amp;a, A&lt;<font color="#dd0000">T</font>&gt; &amp;b);</p>
<ol start="2">
<li><em><strong>友元函数实现 必须写成</strong></em></li>
</ol>
<p><strong>template</strong> &lt;typename <font color="#dd0000">T </font>&gt;<br><strong>A</strong>&lt; <font color="#dd0000">T</font>&gt; <em>add</em>(<strong>A</strong>&lt; <font color="#dd0000">T</font>&gt; &amp;a, <strong>A</strong>&lt; <font color="#dd0000">T</font>&gt; &amp;b)<br>            {<br>                    //……<br>}</p>
<ol start="3">
<li><em><strong>友元函数调用 必须写成</strong></em></li>
</ol>
<p><strong>A</strong><int> c4 = <strong>addA</strong><int>(c1, c2);</p>
<h1 id="类模板与static成员"><a href="#类模板与static成员" class="headerlink" title="类模板与static成员"></a>类模板与static成员</h1><p><font color=#999AAA >代码示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	A(T t=0);</span><br><span class="line"></span><br><span class="line">	T &amp;getT();</span><br><span class="line"></span><br><span class="line">	A operator +(const A &amp;other);</span><br><span class="line"></span><br><span class="line">	void print();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	static int count;</span><br><span class="line">private:</span><br><span class="line">	T t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; int A&lt;T&gt;::count = 666;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">A&lt;T&gt;::A(T t)</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;t = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">T &amp;A&lt;T&gt;::getT()</span><br><span class="line">&#123;</span><br><span class="line">	return t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">A&lt;T&gt; A&lt;T&gt;::operator+(const A&lt;T&gt; &amp;other)&#123;</span><br><span class="line">	A tmp; //类的内部类型可以显示声明也可以不显示</span><br><span class="line">	tmp.t =this-&gt;t + other.t;</span><br><span class="line">	return tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void A&lt;T&gt;::print()&#123;</span><br><span class="line">	cout&lt;&lt;this-&gt;t&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line"></span><br><span class="line">	A&lt;int&gt;  a(666), b(888);</span><br><span class="line">	A&lt;int&gt; tmp = a + b;</span><br><span class="line"></span><br><span class="line">	A&lt;float&gt; c(777), d(999);</span><br><span class="line"></span><br><span class="line">	a.count = 888;</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;&quot;b.count:&quot;&lt;&lt;b.count&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;&quot;c.count:&quot;&lt;&lt;c.count&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;d.count:&quot;&lt;&lt;d.count&lt;&lt;endl;</span><br><span class="line">	c.count = 1000;</span><br><span class="line">	cout&lt;&lt;&quot;修改后, d.count:&quot;&lt;&lt;d.count&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类模板static总结"><a href="#类模板static总结" class="headerlink" title="类模板static总结"></a>类模板static总结</h2><ol>
<li><strong>从类模板实例化的每个模板类有自己的类模板数据成员，该模板类的所有对象共享一个<font color="#dd0000">static</font>数据成员</strong></li>
<li><strong>和非模板类的static数据成员一样，模板类的<font color="#dd0000">static</font>数据成员也应该在文件范围定义和初始化</strong></li>
<li><strong><font color="#dd0000">static</font> 数据成员也可以使用虚拟类型参数<font color="#dd0000">T</font></strong></li>
</ol>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Gtest安装以及错误解决</title>
    <url>/2021/12/14/Gtest//</url>
    <content><![CDATA[<h1 id="Gtest安装"><a href="#Gtest安装" class="headerlink" title="Gtest安装"></a><strong>Gtest安装</strong></h1><ul>
<li><code> sudo apt-get install git</code></li>
<li><code> git clone https://github.com/google/googletest.git</code></li>
<li> 或者在<a href="https://github.com/google/googletest">Windows浏览器下载</a>再利用samba服务器传输到Linux下</li>
<li> <code>cd googletest </code></li>
<li> <code>cmake .</code></li>
<li> <code>make</code></li>
<li> <code>ls lib</code></li>
</ul>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h2 id="在make时报错"><a href="#在make时报错" class="headerlink" title="在make时报错:"></a><strong>在make时报错:</strong></h2><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://s3.bmp.ovh/imgs/2021/12/054ee1afb84325bb.png"></h2><p><strong>在 CMakeList.txt 里面加上</strong><br><code> SET(CMAKE_CXX_FLAGS &quot;-std=c++11&quot;)</code></p>
<hr>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://i.bmp.ovh/imgs/2021/12/bedd24703dac8e3b.png"></h2><p><strong>再次执行</strong><code>cmake .</code> <strong>&amp;&amp;</strong> <code>cmake</code></p>
<h2 id="成功"><a href="#成功" class="headerlink" title="成功:"></a><strong>成功:</strong></h2><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="https://i.bmp.ovh/imgs/2021/12/ebe147683b8300ef.png"></h2>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程listen函数</title>
    <url>/2021/12/20/Listen//</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt; /* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int listen(int sockfd, int backlog);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>sockfd:</strong><br>    socket文件描述符<br><strong>backlog:</strong><br>    在Linux 系统中，它是指排队等待建立3次握手队列长度<br>查看系统默认backlog<br><code>cat /proc/sys/net/ipv4/tcp_max_syn_backlog</code></p>
</blockquote>
<blockquote>
<p>改变 系统限制的backlog 大小<br>vim /etc/sysctl.conf<br>最后添加<br>net.core.somaxconn = 1024<br>net.ipv4.tcp_max_syn_backlog = 1024<br>保存，然后执行<br>sysctl -p</p>
</blockquote>
<p><strong>典型的服务器程序可以同时服务于多个客户端，当有客户端发起连接时，服务器调用的accept()返回并接受这个连接，如果有大量的客户端发起连接而服务器来不及处理，尚未accept的客户端就处于连接等待状态，listen()声明sockfd处于监听状态，并且最多允许有backlog个客户端处于连接待状态，如果接收到更多的连接请求就忽略。listen()成功返回0，失败返回-1。</strong></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MakeFile</title>
    <url>/2022/01/27/MakeFile//</url>
    <content><![CDATA[<p><font color='red'> <strong>为什么要用MakeFile?</strong> </font><br></p>
<blockquote>
<p><strong>当工程文件需要编译大多数文件时每个文件都需要输入文件名进行编译，出错率高，并且不方便。</strong></p>
</blockquote>
<h1 id="MakeFile-编写"><a href="#MakeFile-编写" class="headerlink" title="MakeFile 编写"></a>MakeFile 编写</h1><h2 id="程序的编译和链接"><a href="#程序的编译和链接" class="headerlink" title="程序的编译和链接"></a>程序的编译和链接</h2><blockquote>
<ul>
<li><strong>使用C、C++编写可执行程序，首先要把源文件编译成中间代码文件，Linux下是 .o 文件，即 Object File，这个动作叫做编译（compile）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。</strong></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>一个项目，拥有成百上千的源程序文件，编译链接这些源文件都是由规则的，Makefile闪亮登场！Makefile确定整个工程的编译规则,只需要一个make命令，就可以实现“自动化编译”。make是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。</strong></li>
</ul>
</blockquote>
<h2 id="Make-工作原理"><a href="#Make-工作原理" class="headerlink" title="Make 工作原理"></a>Make 工作原理</h2><p>通常在一个项目里，我们的规则是：<br></p>
<blockquote>
<p><em>1）</em><strong>如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。<br></strong><br><em>2）</em><strong>如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。<br></strong><br><em>3）</em><strong>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。</strong></p>
</blockquote>
<p>只要我们的<font color='red'> <strong>Makefile</strong> </font>写得够好，我们只用一个<font color='red'> <strong>make</strong> </font>命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。</p>
<p><font color='red'> <strong>Makefile</strong> </font>的<strong>规则:</strong></p>
<blockquote>
<p>target … : prerequisites …<br><br>command<br>…<br>…</p>
</blockquote>
<blockquote>
<p><strong>target也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，暂不叙述。</strong></p>
</blockquote>
<blockquote>
<p><strong>prerequisites就是，要生成那个target所需要的文件或是目标。</strong></p>
</blockquote>
<blockquote>
<p><strong>command也就是make需要执行的命令。（任意的Shell命令）</strong></p>
</blockquote>
<p>这是一个文件的<strong>依赖关系</strong>，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是<font color='red'> <strong>Makefile</strong> </font>的规则。也就是<font color='red'> <strong>Makefile</strong> </font>中最<strong>核心</strong>的内容。</p>
<h2 id="一个范例："><a href="#一个范例：" class="headerlink" title="一个范例："></a><strong>一个范例：</strong><br></h2><p><strong>hellospeak.h:</strong><br><img src="https://i.bmp.ovh/imgs/2022/01/d5eb9c8515c41f80.png"><br><br><br><strong>speak.h</strong><br><img src="https://i.bmp.ovh/imgs/2022/01/db3fc86d82cc2da3.png"><br><br><br><strong>speak.c:</strong><br><img src="https://i.bmp.ovh/imgs/2022/01/f081c8addf6fb283.png"><br><br><br><strong>若是用gcc编译将执行三步:</strong><br><img src="https://i.bmp.ovh/imgs/2022/01/bc93ac67bfd7422a.png"></p>
<p><strong>CmakeFile范例</strong><br></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">hello_demo : hellospeak.o speak.o                                           </span><br><span class="line">        gcc -o hello_demo hellospeak.o speak.o                               </span><br><span class="line"></span><br><span class="line">hellospeak.o : hellospeak.c speak.h                                           </span><br><span class="line">        gcc -c hellospeak.c                                                </span><br><span class="line">speak.o : speak.c  speak.h                                                  </span><br><span class="line">        gcc -c speak.c                                                    </span><br><span class="line">clean :  <span class="comment">/*执行 make clean 将会删除下面文件*/</span>                                                    </span><br><span class="line">        rm hello_demo speak.o  hellospeak.o                                </span><br></pre></td></tr></table></figure>
<p><strong>写完这个文件将直接执行make就可以</strong></p>
<h2 id="Make-工作流程"><a href="#Make-工作流程" class="headerlink" title="Make 工作流程"></a>Make 工作流程</h2><blockquote>
<p><strong>1、make会在当前目录下找名字叫“Makefile”或“makefile”的文件。<br><br>2、如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到”hello_demo”这个文件，并把这个文件作为最终的目标文件。<br><br>3、如果hello_demo文件不存在，或是hello_demo所依赖的后面的 .o 文件的文件修改时间要比hello_demo这个文件新，那么，他就会执行后面所定义的命令来生成hello_demo这个文件。<br><br>4、如果hello_demo所依赖的.o文件也不存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（像不像堆栈过程？）<br><br>5、当然，我们的C文件和H文件都存在，于是make会生成 .o 文件，然后再用 .o 文件生命make的终极任务，也就是执行文件hello_demo了。<br></strong></p>
</blockquote>
<h2 id="Make-变量"><a href="#Make-变量" class="headerlink" title="Make 变量"></a>Make 变量</h2><p>一个Makefile里我们发现经常会由重复的内容，如上面范例中的前两行中的<br><code>hellospeak.o speak.o</code>                                                      </p>
<blockquote>
<p>如果我们的工程需要加入一个新的[.o]文件，那么我们好几个地方都需要修改原来的makefile。当然，我们的makefile并不复杂，所以在两个地方加也不累，但如果makefile变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了makefile的易维护，在makefile中我们可以使用变量。makefile的变量也就是一个字符串，完全可以理解成<strong>C语言中的宏</strong>。</p>
</blockquote>
<p>变量定义:   变量名 = 值   ##使用shell script 的语法<br>如：<br><code>objects =  hellospeak.o speak.o</code>                                        </p>
<p>我们上面的makefile 就可以变成:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">objects = hellospeak.o speak.o                                               </span><br><span class="line">hello_demo : $(objects)                                                   </span><br><span class="line">        gcc -o hello_demo $(objects)                                        </span><br><span class="line"></span><br><span class="line">hellospeak.o : hellospeak.c speak.h                                           </span><br><span class="line">        gcc -c hellospeak.c                                                </span><br><span class="line">speak.o : speak.c  speak.h                                                  </span><br><span class="line">        gcc -c speak.c       </span><br><span class="line">.PHONY : clean                                              </span><br><span class="line">clean :                                                                  </span><br><span class="line">        -rm hello_demo  $(objects)</span><br></pre></td></tr></table></figure>
<h2 id="Make-自动推导"><a href="#Make-自动推导" class="headerlink" title="Make 自动推导"></a>Make 自动推导</h2><p>make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。</p>
<p>只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个hello.o，那么hello.c，就会是hello.o的依赖文件。并且 gcc -c hello.c 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的新的makefile又出炉了.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">objects = hellospeak.o speak.o                                                   </span><br><span class="line">hello_demo : $(objects)                                                        </span><br><span class="line">        gcc -o hello_demo $(objects)                                            </span><br><span class="line">                                                                           </span><br><span class="line">$(objects):speak.h                                                             </span><br><span class="line"><span class="meta">#hellospeak.o : hellospeak.c speak.h                                              </span></span><br><span class="line"><span class="meta">#       gcc -c hellospeak.c                                                    </span></span><br><span class="line"><span class="meta">#speak.o : speak.c  speak.h                                                     </span></span><br><span class="line"><span class="meta">#       gcc -c speak.c                                                        </span></span><br><span class="line">                                                                           </span><br><span class="line">.PHONY : clean                                                              </span><br><span class="line">clean :                                                                      </span><br><span class="line">        -rm hello_demo  $(objects)</span><br></pre></td></tr></table></figure>

<h1 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h1><ul>
<li>你或许听过好几种 Make 工具，例如 GNU Make ，QT 的 qmake ，微软的 MS nmake，BSD Make（pmake），Makepp，等等。这些 Make 工具遵循着不同的规范和标准，所执行的 Makefile 格式也千差万别。这样就带来了一个严峻的问题：如果软件想跨平台，必须要保证能够在不同平台编译。而如果使用上面的 Make 工具，就得为每一种标准写一次 Makefile ，这将是一件让人抓狂的工作。<br></li>
<li>CMake就是针对上面问题所设计的工具：它首先允许开发者编写一种平台无关的 CMakeList.txt 文件来定制整个编译流程，然后再根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件，如 Unix 的 Makefile 或 Windows 的 Visual Studio 工程。从而做到“Write once, run everywhere”。显然，CMake 是一个比上述几种 make 更高级的编译配置工具。一些使用 CMake 作为项目架构系统的知名开源项目有 VTK、ITK、KDE、OpenCV、OSG 等 。</li>
</ul>
<p> 安装cmake:<br> <code>sudo apt-get install cmake</code></p>
<p><strong>在 linux 平台下使用 CMake 生成 Makefile 并编译的流程如下：</strong></p>
<blockquote>
<p>1.编写 CMake 配置文件 CMakeLists.txt 。<br><br>2.执行命令 cmake PATH 生成 Makefile。其中， PATH 是 CMakeLists.txt 所在的目录。<br><br>3.使用 make 命令进行编译。<br></p>
</blockquote>
<p><strong>Cmake范例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#CMake 最低版本要求</span><br><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.10</span><span class="number">.2</span>)</span><br><span class="line"></span><br><span class="line">#项目信息</span><br><span class="line"><span class="built_in">project</span>(HelloSpeak)</span><br><span class="line"></span><br><span class="line">#指定生成的目标</span><br><span class="line"><span class="built_in">add_executable</span>(CmakeHelloSpeak speak.c hellospeak.c)</span><br></pre></td></tr></table></figure>

<p><strong>执行cmake . 将会生成makefile文件</strong><br><img src="https://i.bmp.ovh/imgs/2022/01/c585e6e7992b6de3.png"><br><strong>执行make 将会生成三个文件</strong><br><img src="https://i.bmp.ovh/imgs/2022/01/fbee876d573ebb6c.png"></p>
<hr>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt 电子时钟</title>
    <url>/2021/12/18/QtClock//</url>
    <content><![CDATA[<blockquote>
<p>预览效果:<img src="https://img-blog.csdnimg.cn/396f31d658d24a04ae309bf37aa3f5c8.gif#pic_center" alt="在这里插入图片描述"><br><strong>左键点击不松手移动,右键点击关闭</strong></p>
</blockquote>
<p>第一步创建项目</p>
<p><img src="https://img-blog.csdnimg.cn/e84979f8d32c449997212453a74506e0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAX1NwYWNlXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/9243b519148f425eb74ab0d8b35c9a94.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAX1NwYWNlXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/16777992bd814bd586666e0ccca25846.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAX1NwYWNlXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="根据系统选择合适的"><br>右键点击项目添加新文件<br><img src="https://img-blog.csdnimg.cn/d4da6b5593fe44a4be8cdba4306b753c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAX1NwYWNlXw==,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>选择C++类<br><img src="https://img-blog.csdnimg.cn/3b9b1aaac16e46f69926aec2e0e3b824.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAX1NwYWNlXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>该类继承自 <strong>QLCDNumber</strong><br><img src="https://img-blog.csdnimg.cn/c9eddf3b0bd848f6a5275823c1c85eba.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAX1NwYWNlXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>clock.h代码实现:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CLOCK_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLOCK_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDialog&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> :</span> <span class="keyword">public</span> QDialog</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Clock</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Clock</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// CLOCK_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>clock.cpp代码实现:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;clock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Clock::<span class="built_in">Clock</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QDialog</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Clock::~<span class="built_in">Clock</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>DigitalClock.h代码实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DIGITALCLOCK_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DIGITALCLOCK_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLCDNumber&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DigitalClock</span> :</span> <span class="keyword">public</span> QLCDNumber</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DigitalClock</span>(QWidget *parent = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPoint m_dragPosition;</span><br><span class="line">    <span class="keyword">bool</span> m_showColon;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DIGITALCLOCK_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>DigitalClock.cpp代码实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;digitalclock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMouseEvent&gt;</span></span></span><br><span class="line"></span><br><span class="line">DigitalClock::<span class="built_in">DigitalClock</span>(QWidget *parent):<span class="built_in">QLCDNumber</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    QPalette p = <span class="built_in">palette</span>();<span class="comment">//获取当前调色板</span></span><br><span class="line">    p.<span class="built_in">setColor</span>(QPalette::Window,Qt::blue);   <span class="comment">//对窗体设置颜色</span></span><br><span class="line">    <span class="built_in">setPalette</span>(p);      <span class="comment">//设置调色板</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//无边框风格</span></span><br><span class="line">    <span class="built_in">setWindowFlags</span>(Qt::FramelessWindowHint);</span><br><span class="line">    <span class="built_in">setWindowOpacity</span>(<span class="number">0.5</span>);      <span class="comment">//窗体透明度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    QTimer *timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(timer,&amp;QTimer::timeout,<span class="keyword">this</span>,&amp;DigitalClock::showTime);</span><br><span class="line">    timer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">resize</span>(<span class="number">150</span>,<span class="number">60</span>);</span><br><span class="line">    m_showColon = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigitalClock::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//左键</span></span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">button</span>() == Qt::LeftButton)&#123;</span><br><span class="line">        <span class="comment">//鼠标相对屏幕左上角的位置               时钟窗体左上角位置</span></span><br><span class="line">        m_dragPosition = event-&gt;<span class="built_in">globalPos</span>()-<span class="built_in">frameGeometry</span>().<span class="built_in">topLeft</span>();</span><br><span class="line">        event-&gt;<span class="built_in">accept</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右键关闭</span></span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">button</span>() == Qt::RightButton)&#123;</span><br><span class="line">       <span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigitalClock::mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">buttons</span>() &amp; Qt::LeftButton)&#123;</span><br><span class="line">        <span class="built_in">move</span>(event-&gt;<span class="built_in">globalPos</span>()-m_dragPosition);</span><br><span class="line">        event-&gt;<span class="built_in">accept</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigitalClock::showTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//当前时间</span></span><br><span class="line">    QTime time = QTime::<span class="built_in">currentTime</span>();</span><br><span class="line">    QString strTimer = time.<span class="built_in">toString</span>(<span class="string">&quot;hh:mm&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(m_showColon)&#123;</span><br><span class="line">        strTimer[<span class="number">2</span>] = <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        strTimer[<span class="number">2</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示</span></span><br><span class="line">    <span class="built_in">display</span>(strTimer);</span><br><span class="line"></span><br><span class="line">    m_showColon = !m_showColon;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>main.cpp代码实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;clock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;digitalclock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    DigitalClock w;</span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt QPalette调色板</title>
    <url>/2021/12/16/QtQPalette//</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><font color=#999AAA >
Qt提供的调色板类 QPalette 专门用于管理部件的外观显示,相当于部件或对话框的调色板,管理他们所有的颜色信息,每一个部件都包含一个 QPalette 对象,在显示时,按照它的 QPalette 对象中对各部分各状态下的颜色的描述进行绘制
</font>




<hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1">
<hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1">
<hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1">


<blockquote>
<p>调色板运用<br>效果图:<img src="https://img-blog.csdnimg.cn/09e6e73eee5c4327b926d8850097b3dd.gif#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1">



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DIALOG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DIALOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QFrame&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QComboBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTextEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dialog</span> :</span> <span class="keyword">public</span> QDialog</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dialog</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Dialog</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createCtrlFrame</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createContentFrame</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fillColorList</span><span class="params">(QComboBox* comboBox)</span></span>;    <span class="comment">//组合框添加颜色链表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowWindow</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowWindowText</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowButton</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowButtonText</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowBase</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QFrame *m_ctrlFrame;</span><br><span class="line"></span><br><span class="line">    QLabel *m_windowLabel;</span><br><span class="line">    QComboBox *m_windowComboBox;</span><br><span class="line"></span><br><span class="line">    QLabel *m_windowTextLabel;</span><br><span class="line">    QComboBox *m_windowTextComboBox;</span><br><span class="line"></span><br><span class="line">    QLabel *m_buttonLabel;</span><br><span class="line">    QComboBox *m_buttonLabelComboBox;</span><br><span class="line"></span><br><span class="line">    QLabel *m_buttonTextLabel;</span><br><span class="line">    QComboBox *m_buttonTextComboBox;</span><br><span class="line"></span><br><span class="line">    QLabel *m_baseLabel;</span><br><span class="line">    QComboBox *m_baseComboBox;</span><br><span class="line"></span><br><span class="line">    QFrame *m_contentFrame;</span><br><span class="line"></span><br><span class="line">    QLabel *m_label1;</span><br><span class="line">    QLabel *m_label2;</span><br><span class="line"></span><br><span class="line">    QComboBox *m_comboBox1;</span><br><span class="line">    QLineEdit *m_lineEdit;</span><br><span class="line">    QTextEdit *m_textEdit;</span><br><span class="line">    QPushButton *m_okBtn;</span><br><span class="line">    QPushButton *m_canceBtn;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DIALOG_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QGridLayout&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dialog::<span class="built_in">Dialog</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QDialog</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot;QPalette&quot;</span>);</span><br><span class="line">    <span class="built_in">setWindowFlags</span>(Qt::WindowCloseButtonHint);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">createCtrlFrame</span>();</span><br><span class="line">    <span class="built_in">createContentFrame</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//水平布局</span></span><br><span class="line">    QHBoxLayout *mainLayout = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>(<span class="keyword">this</span>);</span><br><span class="line">    mainLayout-&gt;<span class="built_in">addWidget</span>(m_ctrlFrame);</span><br><span class="line">    mainLayout-&gt;<span class="built_in">addWidget</span>(m_contentFrame);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dialog::~<span class="built_in">Dialog</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dialog::createCtrlFrame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_ctrlFrame = <span class="keyword">new</span> QFrame;</span><br><span class="line">    m_ctrlFrame-&gt;<span class="built_in">setFrameStyle</span>(QFrame::Sunken | QFrame::Box);       <span class="comment">//设置风格</span></span><br><span class="line">    m_windowLabel = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;QPalette::Window:&quot;</span>);</span><br><span class="line">    m_windowComboBox = <span class="keyword">new</span> QComboBox;</span><br><span class="line">    <span class="built_in">fillColorList</span>(m_windowComboBox);        <span class="comment">//填充颜色</span></span><br><span class="line">    <span class="built_in">connect</span>(m_windowComboBox,<span class="built_in">SIGNAL</span>(<span class="built_in">activated</span>(<span class="keyword">int</span>)),<span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">ShowWindow</span>(<span class="keyword">int</span>)));</span><br><span class="line"></span><br><span class="line">    m_windowTextLabel = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;QPalette::WindowText:&quot;</span>);</span><br><span class="line">    m_windowTextComboBox = <span class="keyword">new</span> QComboBox;</span><br><span class="line">    <span class="built_in">fillColorList</span>(m_windowTextComboBox);</span><br><span class="line">    <span class="built_in">connect</span>(m_windowTextComboBox,<span class="built_in">SIGNAL</span>(<span class="built_in">activated</span>(<span class="keyword">int</span>)),<span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">ShowWindowText</span>(<span class="keyword">int</span>)));</span><br><span class="line"></span><br><span class="line">    m_buttonLabel = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;QPatte::Button:&quot;</span>);</span><br><span class="line">    m_buttonLabelComboBox = <span class="keyword">new</span> QComboBox;</span><br><span class="line">    <span class="built_in">fillColorList</span>(m_buttonLabelComboBox);</span><br><span class="line">    <span class="built_in">connect</span>(m_buttonLabelComboBox,<span class="built_in">SIGNAL</span>(<span class="built_in">activated</span>(<span class="keyword">int</span>)),<span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">ShowButton</span>(<span class="keyword">int</span>)));</span><br><span class="line"></span><br><span class="line">    m_buttonTextLabel = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;QPatte::ButtonText:&quot;</span>);</span><br><span class="line">    m_buttonTextComboBox = <span class="keyword">new</span> QComboBox;</span><br><span class="line">    <span class="built_in">fillColorList</span>(m_buttonTextComboBox);</span><br><span class="line">    <span class="built_in">connect</span>(m_buttonTextComboBox,<span class="built_in">SIGNAL</span>(<span class="built_in">activated</span>(<span class="keyword">int</span>)),<span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">ShowButtonText</span>(<span class="keyword">int</span>)));</span><br><span class="line"></span><br><span class="line">    m_baseLabel = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;QPalette::Base:&quot;</span>);</span><br><span class="line">    m_baseComboBox = <span class="keyword">new</span> QComboBox;</span><br><span class="line">    <span class="built_in">fillColorList</span>(m_baseComboBox);</span><br><span class="line">    <span class="built_in">connect</span>(m_baseComboBox,<span class="built_in">SIGNAL</span>(<span class="built_in">activated</span>(<span class="keyword">int</span>)),<span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">ShowBase</span>(<span class="keyword">int</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//格线布局</span></span><br><span class="line">    QGridLayout *mainLayout = <span class="keyword">new</span> <span class="built_in">QGridLayout</span>(m_ctrlFrame);</span><br><span class="line">    mainLayout-&gt;<span class="built_in">setSpacing</span>(<span class="number">20</span>); <span class="comment">//设置间隙</span></span><br><span class="line">    mainLayout-&gt;<span class="built_in">addWidget</span>(m_windowLabel,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    mainLayout-&gt;<span class="built_in">addWidget</span>(m_windowComboBox,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    mainLayout-&gt;<span class="built_in">addWidget</span>(m_windowTextLabel,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    mainLayout-&gt;<span class="built_in">addWidget</span>(m_windowTextComboBox,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    mainLayout-&gt;<span class="built_in">addWidget</span>(m_buttonLabel,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    mainLayout-&gt;<span class="built_in">addWidget</span>(m_buttonLabelComboBox,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    mainLayout-&gt;<span class="built_in">addWidget</span>(m_buttonTextLabel,<span class="number">3</span>,<span class="number">0</span>);</span><br><span class="line">    mainLayout-&gt;<span class="built_in">addWidget</span>(m_buttonTextComboBox,<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">    mainLayout-&gt;<span class="built_in">addWidget</span>(m_baseLabel,<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line">    mainLayout-&gt;<span class="built_in">addWidget</span>(m_baseComboBox,<span class="number">4</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dialog::createContentFrame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_contentFrame = <span class="keyword">new</span> QFrame;</span><br><span class="line">    m_contentFrame-&gt;<span class="built_in">setAutoFillBackground</span>(<span class="literal">true</span>);</span><br><span class="line">    m_label1 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;请选择一个值&quot;</span>);</span><br><span class="line">    m_label2 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;请输入字符串&quot;</span>);</span><br><span class="line">    m_comboBox1 = <span class="keyword">new</span> QComboBox;</span><br><span class="line">    m_lineEdit = <span class="keyword">new</span> QLineEdit;</span><br><span class="line">    m_textEdit = <span class="keyword">new</span> QTextEdit;</span><br><span class="line">    m_okBtn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="built_in">QString</span>(<span class="string">&quot;确认&quot;</span>));</span><br><span class="line">    m_canceBtn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="built_in">QString</span>(<span class="string">&quot;取消&quot;</span>));</span><br><span class="line">    m_okBtn-&gt;<span class="built_in">setAutoFillBackground</span>(<span class="literal">true</span>);   <span class="comment">//背景自动填充</span></span><br><span class="line"></span><br><span class="line">    QGridLayout *Toplayout = <span class="keyword">new</span> QGridLayout;</span><br><span class="line">    Toplayout-&gt;<span class="built_in">addWidget</span>(m_label1 ,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    Toplayout-&gt;<span class="built_in">addWidget</span>(m_comboBox1,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    Toplayout-&gt;<span class="built_in">addWidget</span>(m_label2,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    Toplayout-&gt;<span class="built_in">addWidget</span>(m_lineEdit,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    Toplayout-&gt;<span class="built_in">addWidget</span>(m_textEdit,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    QHBoxLayout *bottomLayout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    bottomLayout-&gt;<span class="built_in">addWidget</span>(m_okBtn);</span><br><span class="line">    bottomLayout-&gt;<span class="built_in">addWidget</span>(m_canceBtn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//垂直布局</span></span><br><span class="line">    QVBoxLayout *mainLayout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(m_contentFrame);</span><br><span class="line">    mainLayout-&gt;<span class="built_in">addLayout</span>(Toplayout);</span><br><span class="line">    mainLayout-&gt;<span class="built_in">addLayout</span>(bottomLayout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dialog::fillColorList</span><span class="params">(QComboBox *comboBox)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将所有颜色放入链表</span></span><br><span class="line">    QStringList colorList = QColor::<span class="built_in">colorNames</span>();</span><br><span class="line"></span><br><span class="line">    QString color;</span><br><span class="line">    foreach(color,colorList)&#123;</span><br><span class="line">        <span class="function">QPixmap <span class="title">pix</span><span class="params">(QSize(<span class="number">70</span>,<span class="number">20</span>))</span></span>;</span><br><span class="line">        pix.<span class="built_in">fill</span>(<span class="built_in">QColor</span>(color));</span><br><span class="line">        comboBox-&gt;<span class="built_in">addItem</span>(<span class="built_in">QIcon</span>(pix),<span class="literal">NULL</span>);</span><br><span class="line">        comboBox-&gt;<span class="built_in">setIconSize</span>(<span class="built_in">QSize</span>(<span class="number">70</span>,<span class="number">20</span>));</span><br><span class="line">        <span class="comment">//根据内容进行适应</span></span><br><span class="line">        comboBox-&gt;<span class="built_in">setSizeAdjustPolicy</span>(QComboBox::AdjustToContents);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dialog::ShowWindow</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QStringList colorList = QColor::<span class="built_in">colorNames</span>();</span><br><span class="line">    QColor color = <span class="built_in">QColor</span>(colorList[index]);</span><br><span class="line">    QPalette p = m_contentFrame-&gt;<span class="built_in">palette</span>();</span><br><span class="line">    p.<span class="built_in">setColor</span>(QPalette::Window,color);</span><br><span class="line">    m_contentFrame-&gt;<span class="built_in">setPalette</span>(p);</span><br><span class="line">    <span class="comment">//触发重绘</span></span><br><span class="line">    m_contentFrame-&gt;<span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dialog::ShowWindowText</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QStringList colorList = QColor::<span class="built_in">colorNames</span>();</span><br><span class="line">    QColor color = <span class="built_in">QColor</span>(colorList[index]);</span><br><span class="line"></span><br><span class="line">    QPalette p = m_contentFrame-&gt;<span class="built_in">palette</span>();</span><br><span class="line">    p.<span class="built_in">setColor</span>(QPalette::WindowText,color);</span><br><span class="line">    m_contentFrame-&gt;<span class="built_in">setPalette</span>(p);</span><br><span class="line">    m_contentFrame-&gt;<span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dialog::ShowButton</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QStringList colorList = QColor::<span class="built_in">colorNames</span>();</span><br><span class="line">    QColor color = <span class="built_in">QColor</span>(colorList[index]);</span><br><span class="line"></span><br><span class="line">    QPalette p = m_contentFrame-&gt;<span class="built_in">palette</span>();</span><br><span class="line">    p.<span class="built_in">setColor</span>(QPalette::Button,color);</span><br><span class="line">    m_contentFrame-&gt;<span class="built_in">setPalette</span>(p);</span><br><span class="line">    m_contentFrame-&gt;<span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dialog::ShowButtonText</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QStringList colorList = QColor::<span class="built_in">colorNames</span>();</span><br><span class="line">    QColor color = <span class="built_in">QColor</span>(colorList[index]);</span><br><span class="line"></span><br><span class="line">    QPalette p = m_contentFrame-&gt;<span class="built_in">palette</span>();</span><br><span class="line">    p.<span class="built_in">setColor</span>(QPalette::ButtonText,color);</span><br><span class="line">    m_contentFrame-&gt;<span class="built_in">setPalette</span>(p);</span><br><span class="line">    m_contentFrame-&gt;<span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dialog::ShowBase</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QStringList colorList = QColor::<span class="built_in">colorNames</span>();</span><br><span class="line">    QColor color = <span class="built_in">QColor</span>(colorList[index]);</span><br><span class="line"></span><br><span class="line">    QPalette p = m_contentFrame-&gt;<span class="built_in">palette</span>();</span><br><span class="line">    p.<span class="built_in">setColor</span>(QPalette::Base,color);</span><br><span class="line">    m_contentFrame-&gt;<span class="built_in">setPalette</span>(p);</span><br><span class="line">    m_contentFrame-&gt;<span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt 窗体透明,部件透明及阴影与不规则窗体</title>
    <url>/2021/12/17/QtWinShade//</url>
    <content><![CDATA[<font color=#999AAA >
</font>

<p>@<a href="%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">TOC</a></p>
<hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1">


<h1 id="一、窗口透明"><a href="#一、窗口透明" class="headerlink" title="一、窗口透明"></a>一、窗口透明</h1><p><font color=#999AAA >示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//窗口透明,取值0~1，0表示完全透明,1表示完全不透明</span></span><br><span class="line"><span class="built_in">setWindowOpacity</span>(<span class="number">0.5</span>);</span><br></pre></td></tr></table></figure>
<p><font color=#999AAA >样例：<br><img src="https://img-blog.csdnimg.cn/29c1ecb0b1fc47d6ac503c2c9f3f7929.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAX1NwYWNlXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="1-窗口透明-部件不透明"><a href="#1-窗口透明-部件不透明" class="headerlink" title="1.窗口透明,部件不透明"></a>1.窗口透明,部件不透明</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//窗体透明部件不透明windows需配合无边框风格实现</span></span><br><span class="line">   <span class="built_in">setWindowFlags</span>(Qt::FramelessWindowHint);</span><br><span class="line">   <span class="built_in">setAttribute</span>(Qt::WA_TranslucentBackground);</span><br></pre></td></tr></table></figure>



<p><img src="https://img-blog.csdnimg.cn/cb8e637b25154f81af6bf472259771a7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAX1NwYWNlXw==,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="二、部件透明"><a href="#二、部件透明" class="headerlink" title="二、部件透明"></a>二、部件透明</h1><p><font color=#999AAA >代码如下（示例）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//需添加头文件 #include &lt;QGraphicsOpacityEffect&gt;</span></span><br><span class="line"></span><br><span class="line">   	QGraphicsOpacityEffect *opacityEffect = <span class="keyword">new</span> QGraphicsOpacityEffect;</span><br><span class="line">    <span class="comment">//设置透明度</span></span><br><span class="line">    opacityEffect-&gt;<span class="built_in">setOpacity</span>(<span class="number">0.1</span>);</span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">setGraphicsEffect</span>(opacityEffect);</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/a0665f3d82d44b7f8de5dc591175688e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAX1NwYWNlXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="1-部件设置阴影"><a href="#1-部件设置阴影" class="headerlink" title="1.部件设置阴影"></a>1.部件设置阴影</h2><p><font color=#999AAA >代码如下（示例）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需添加头文件#include &lt;QGraphicsDropShadowEffect &gt;</span></span><br><span class="line"></span><br><span class="line"> 	 QGraphicsDropShadowEffect *shadowEffect = <span class="keyword">new</span> QGraphicsDropShadowEffect;</span><br><span class="line">    <span class="comment">//阴影色，透明度</span></span><br><span class="line">    shadowEffect-&gt;<span class="built_in">setColor</span>(<span class="built_in">QColor</span>(<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>));</span><br><span class="line">    <span class="comment">//阴影模糊半径</span></span><br><span class="line">    shadowEffect-&gt;<span class="built_in">setBlurRadius</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//阴影偏移值</span></span><br><span class="line">    shadowEffect-&gt;<span class="built_in">setXOffset</span>(<span class="number">20</span>);</span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">setGraphicsEffect</span>(shadowEffect);</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/434db2b9c7a64618b5a9693adc2a171c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAX1NwYWNlXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1">

<h1 id="三-、不规则窗体"><a href="#三-、不规则窗体" class="headerlink" title="三 、不规则窗体"></a>三 、不规则窗体</h1><p><strong>此处需重写 <em>painterEvent</em> 事件</strong><br><font color=#999AAA >代码如下（**.h**示例）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *event)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>

<p><font color=#999AAA >代码如下（**.cpp**示例）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数中</span></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    QPixmap pixmap;</span><br><span class="line">    pixmap.<span class="built_in">load</span>(<span class="string">&quot;:/flower.png&quot;</span>);</span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">resize</span>(pixmap.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">resize</span>(pixmap.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">//设置遮罩</span></span><br><span class="line">    <span class="built_in">setMask</span>(pixmap.<span class="built_in">mask</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::paintEvent</span><span class="params">(QPaintEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="built_in">QPixmap</span>(<span class="string">&quot;:/flower.png&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果展示:<img src="https://img-blog.csdnimg.cn/1f5936fd7cf94119bb0b251848223f77.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAX1NwYWNlXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>C++流(读写文件)</title>
    <url>/2021/11/29/ReadWrite//</url>
    <content><![CDATA[<h1 id="读写文本文件"><a href="#读写文本文件" class="headerlink" title="读写文本文件"></a>读写文本文件</h1><blockquote>
<p><strong>C++的IO流:<br>IO:向设备输入数据和输出数据</strong></p>
</blockquote>
<blockquote>
<p><strong>设备有:<br>1)文件<br>2)控制台<br>3)特定的数据类型(stringstream)</strong><br><em><strong>C++中,必须通过特定的已经定义好的类, 来处理IO(输入输出)</strong></em></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/e0bfc49ef70d433abc1b3c487195eda8.png" alt="在这里插入图片描述"></p>
<p>C++的 IO类库为:</p>
<p><img src="https://img-blog.csdnimg.cn/027d746213614c3e9eb335d14a99988c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MTQwMTkz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>文件流:对文件进行读写操作</strong><br><strong>头文件:  &lt; fstream &gt;</strong></p>
<p><strong>ifstream    对文件输入(读文件)</strong><br><strong>ofstream    对文件输出(写文件)</strong><br><strong>fstream     对文件输入或输出</strong></p>
</blockquote>
<p><strong>文件的打开方式:</strong></p>
<table>
<thead>
<tr>
<th>模式标志</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ios::in</td>
<td>读方式打开文件</td>
</tr>
<tr>
<td>ios:out</td>
<td>写方式打开文件</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果此文件已经存在, 就会打开文件之前把文件长度截断为0</td>
</tr>
<tr>
<td>ios::app</td>
<td>尾部最加方式(在尾部写入)</td>
</tr>
<tr>
<td>ios::ate</td>
<td>文件打开后, 定位到文件尾</td>
</tr>
<tr>
<td>ios::binary</td>
<td>二进制方式(默认是文本方式)</td>
</tr>
</tbody></table>
<p><strong>写文本文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	ofstream outfile;  <span class="comment">//也可以使用fstream, 但是fstream的默认打开方式不截断文件长度</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// ofstream的默认打开方式是,  截断式写入 ios::out |  ios::trunc</span></span><br><span class="line">	<span class="comment">// fstream的默认打开方式是,  截断式写入   ios::out</span></span><br><span class="line">	<span class="comment">// 建议指定打开方式</span></span><br><span class="line">	outfile.<span class="built_in">open</span>(<span class="string">&quot;user.txt&quot;</span>, ios::out | ios::trunc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;[ctrl+z退出]&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入姓名:&quot;</span>;</span><br><span class="line">		cin &gt;&gt; name;</span><br><span class="line">		<span class="keyword">if</span> (cin.<span class="built_in">eof</span>()) &#123; <span class="comment">//判断文件是否结束</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		outfile &lt;&lt; name &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入年龄: &quot;</span>;</span><br><span class="line">		cin &gt;&gt; age;</span><br><span class="line">		outfile &lt;&lt; age &lt;&lt; endl;  <span class="comment">//文本文件写入</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭打开的文件</span></span><br><span class="line">	outfile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>读文本文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	ifstream infile;</span><br><span class="line">	infile.<span class="built_in">open</span>(<span class="string">&quot;user.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		infile &gt;&gt; name;</span><br><span class="line">		<span class="keyword">if</span> (infile.<span class="built_in">eof</span>()) &#123; <span class="comment">//判断文件是否结束</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; name &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line"></span><br><span class="line">		infile &gt;&gt; age;</span><br><span class="line">		cout &lt;&lt; age &lt;&lt; endl;  </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭打开的文件</span></span><br><span class="line">	infile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二进制读写文件"><a href="#二进制读写文件" class="headerlink" title="二进制读写文件"></a>二进制读写文件</h2><blockquote>
<p><strong>写二进制文件<br>使用文件流对象的write方法写入二进制数据.</strong></p>
</blockquote>
<blockquote>
<p><strong>注:若</strong> <del><em><strong>outfile &lt;&lt; age &lt;&lt; end;</strong></em></del><br><strong>写入文件会转换到文本方式写入</strong><br><strong>需要使用write(<em>写</em>)吧整形转换到char类型，进行写入</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	ofstream outfile;</span><br><span class="line">	outfile.<span class="built_in">open</span>(<span class="string">&quot;user.dat&quot;</span>, ios::out | ios::trunc | ios::binary);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入姓名: [ctrl+z退出] &quot;</span>;</span><br><span class="line">		cin &gt;&gt; name;</span><br><span class="line">		<span class="keyword">if</span> (cin.<span class="built_in">eof</span>()) &#123; <span class="comment">//判断文件是否结束</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		outfile &lt;&lt; name &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入年龄: &quot;</span>;</span><br><span class="line">		cin &gt;&gt; age;  </span><br><span class="line">		<span class="comment">//outfile &lt;&lt; age &lt;&lt; endl;  //会自动转成文本方式写入</span></span><br><span class="line">		outfile.<span class="built_in">write</span>((<span class="keyword">char</span>*)&amp;age, <span class="built_in"><span class="keyword">sizeof</span></span>(age));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭打开的文件</span></span><br><span class="line">	outfile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>二进制读文件</strong></p>
<blockquote>
<p><strong>需使用read(<em>读</em>)吧写入的内容读取出来并输出</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	ifstream infile;</span><br><span class="line">	infile.<span class="built_in">open</span>(<span class="string">&quot;user.dat&quot;</span>, ios::in | ios::binary);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		infile &gt;&gt; name;</span><br><span class="line">		<span class="keyword">if</span> (infile.<span class="built_in">eof</span>()) &#123; <span class="comment">//判断文件是否结束</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; name &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// 跳过中间的制表符</span></span><br><span class="line">		<span class="keyword">char</span> tmp;</span><br><span class="line">		infile.<span class="built_in">read</span>(&amp;tmp, <span class="built_in"><span class="keyword">sizeof</span></span>(tmp)); </span><br><span class="line"></span><br><span class="line">		<span class="comment">//infile &gt;&gt; age; //从文本文件中读取整数, 使用这个方式</span></span><br><span class="line">		infile.<span class="built_in">read</span>((<span class="keyword">char</span>*)&amp;age, <span class="built_in"><span class="keyword">sizeof</span></span>(age));</span><br><span class="line">		cout &lt;&lt; age &lt;&lt; endl;  <span class="comment">//文本文件写入</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭打开的文件</span></span><br><span class="line">	infile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="按指定格式读写文件"><a href="#按指定格式读写文件" class="headerlink" title="按指定格式读写文件"></a>按指定格式读写文件</h3><blockquote>
<p><strong>指定格式写文件:</strong><br>使用 <em><strong>&lt; stringstream&gt;</strong></em></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	ofstream outfile;</span><br><span class="line">	outfile.<span class="built_in">open</span>(<span class="string">&quot;user.txt&quot;</span>, ios::out | ios::trunc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;[ctrl+z退出]&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入姓名: &quot;</span>;</span><br><span class="line">		cin &gt;&gt; name;</span><br><span class="line">		<span class="keyword">if</span> (cin.<span class="built_in">eof</span>()) &#123; <span class="comment">//判断文件是否结束</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入年龄: &quot;</span>;</span><br><span class="line">		cin &gt;&gt; age;</span><br><span class="line">		</span><br><span class="line">		stringstream s;</span><br><span class="line">		s &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;\t\tage:&quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">		outfile &lt;&lt; s.<span class="built_in">str</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭打开的文件</span></span><br><span class="line">	outfile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>指定格式读文件:</strong><br><strong>在C++指定格式读文件并没有优雅的解决方案</strong><br><strong>就用C语言的:</strong> <em><strong>sscanf</strong></em></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	string line;</span><br><span class="line">	ifstream infile;</span><br><span class="line">	infile.<span class="built_in">open</span>(<span class="string">&quot;user.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">getline</span>(infile, line);</span><br><span class="line">		<span class="keyword">if</span> (infile.<span class="built_in">eof</span>()) &#123; <span class="comment">//判断文件是否结束</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">sscanf_s</span>(line.<span class="built_in">c_str</span>(), <span class="string">&quot;姓名:%s 年龄:%d&quot;</span>, name, <span class="built_in"><span class="keyword">sizeof</span></span>(name),&amp;age);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;\t\t年龄:&quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	infile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="文件流的状态检查"><a href="#文件流的状态检查" class="headerlink" title="文件流的状态检查"></a>文件流的状态检查</h4><table>
<thead>
<tr>
<th>流</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>is_open()</td>
<td>文件流是否打开成功</td>
</tr>
<tr>
<td>eof()</td>
<td>流是否结束</td>
</tr>
<tr>
<td>fail()</td>
<td>流的failbit或者badbit被置位时, 返回true</td>
</tr>
<tr>
<td>failbit: 出现非致命错误，可挽回, 一般是软件错误</td>
<td>badbit:置位, 出现致命错误, 一般是硬件错误或系统底层错误, 不可挽回</td>
</tr>
<tr>
<td>bad()</td>
<td>流的badbit置位时, 返回true</td>
</tr>
<tr>
<td>good()</td>
<td>流处于有效状态时, 返回true</td>
</tr>
<tr>
<td>clear()</td>
<td>流的所有状态都被复位</td>
</tr>
</tbody></table>
<h5 id="文件流的三种定位-seekg-tellg-seekp"><a href="#文件流的三种定位-seekg-tellg-seekp" class="headerlink" title="文件流的三种定位 seekg tellg seekp"></a>文件流的三种定位 seekg tellg seekp</h5><p><strong>seekg:</strong></p>
<blockquote>
<p><em>seekg( off_type offset,</em>      <strong>//偏移量</strong><br><em>ios::seekdir origin );</em>  <strong>//起始位置</strong><br><strong>作用：设置输入流的位置</strong><br><strong>参数1： 偏移量</strong><br><strong>参数2： 相对位置</strong><br>  <em>beg</em>      <strong>相对于开始位置</strong><br>  <em>cur</em>      <strong>相对于当前位置</strong><br>  <em>end</em>    <strong>相对于结束位置</strong></p>
</blockquote>
<p>获取文件的最后50个字符:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	ifstream infile;</span><br><span class="line"></span><br><span class="line">	infile.<span class="built_in">open</span>(<span class="comment">/*文件名字这里我就不写了*/</span><span class="string">&quot;.cpp&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!infile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="comment">//定位到最后50个字母</span></span><br><span class="line">	infile.<span class="built_in">seekg</span>(<span class="number">-50</span>, infile.end);</span><br><span class="line">	<span class="keyword">while</span> (!infile.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">		string line;</span><br><span class="line">		<span class="built_in">getline</span>(infile, line);</span><br><span class="line">		cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	infile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>tellg:</strong></p>
<blockquote>
<p>返回该输入流的当前位置(距离文件的起始位置的偏移量)</p>
</blockquote>
<p>获取文件的长度:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	ifstream infile;</span><br><span class="line"></span><br><span class="line">	infile.<span class="built_in">open</span>(<span class="comment">/*文件名字这里我就不写了*/</span><span class="string">&quot;.cpp&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!infile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 先把文件指针移动到文件尾</span></span><br><span class="line">	infile.<span class="built_in">seekg</span>(<span class="number">0</span>, infile.end);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> len = infile.<span class="built_in">tellg</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;len:&quot;</span> &lt;&lt; len;</span><br><span class="line"></span><br><span class="line">	infile.<span class="built_in">close</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>seekp</strong></p>
<blockquote>
<p>设置该输出流的位置</p>
</blockquote>
<p>先向新文件写入：”123456789”<br>然后再在第4个字符位置写入”ABC”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	ofstream outfile;</span><br><span class="line"></span><br><span class="line">	outfile.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!outfile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	outfile &lt;&lt; <span class="string">&quot;123456789&quot;</span>;</span><br><span class="line"></span><br><span class="line">	outfile.<span class="built_in">seekp</span>(<span class="number">4</span>, outfile.beg);</span><br><span class="line">	outfile &lt;&lt; <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line"></span><br><span class="line">	outfile.<span class="built_in">close</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="常见的错误"><a href="#常见的错误" class="headerlink" title="常见的错误"></a>常见的错误</h6><blockquote>
<p>   1.文件没有关闭， close()，可能导致写文件失败<br>    2.文件打开方式不合适<br>    3.在VS2015的部分版本中，当sscanf和sscanf_s的格式字符串中含有中文时，可能会读取失败。</p>
</blockquote>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向基础命令</title>
    <url>/2021/12/29/ReverseOrder//</url>
    <content><![CDATA[<h1 id="move"><a href="#move" class="headerlink" title="move:"></a>move:</h1><p><code>mov eax,0xABC     将0xABC 赋值给edx        直接寻址</code><br><code>mov eax,edi        将edi的值赋值给edx        寄存器寻址</code><br><code>mov eax,[edx]    *edx的值赋值给edx        间接寻址</code><br><code>mov eax,[edx+1]    *edx+1的值赋值给edx    变址寻址</code><br><strong>注:</strong><br><code>mov 0xABC , eax  不允许</code><br><code>mov[eax],[edx]   不允许</code></p>
<h1 id="add"><a href="#add" class="headerlink" title="add"></a>add</h1><p><code>add eax,ebx</code><br><code>eax=eax+ebx    直接寻址与间接寻址都可以</code></p>
<h1 id="inc"><a href="#inc" class="headerlink" title="inc"></a>inc</h1><p><code>inc eax</code><br><code>eax=eax+1    当前值+1    自增</code></p>
<h1 id="sub"><a href="#sub" class="headerlink" title="sub"></a>sub</h1><p><code>sub eax,ebx</code><br><code>eax=eax-ebx</code></p>
<p>#dec<br><code>dec eax</code><br><code>eax=eax+1   当前值-1    自减</code></p>
<h1 id="push-and-pop"><a href="#push-and-pop" class="headerlink" title="push and pop"></a>push and pop</h1><p><code>push与pop需要先了解堆栈</code><br><code>堆栈有中: EBP与ESP</code><br><code>EBP,ESP</code><br><code>ESP - EBP &lt; 0==</code><br><strong>得出:</strong><br><strong>EBP大ESP小</strong><br><code>push 1之后 1将会存入到 ESP的内存里面</code><br><code>每次push之后将会把esp-4再将push的存入esp内</code><br><code>push是每次往上走</code><br><code>pop eax 拿出堆栈顶部的内容给 pop指定的地址(只能是寄存器)</code><br><code>pop是每次往下走</code></p>
<h1 id="jmp"><a href="#jmp" class="headerlink" title="jmp"></a>jmp</h1><p><strong>jmp    无条件跳转</strong><br><code>EIP 是控制代码执行的位置 第1行，第2行，第3行... , 第i行</code><br><code>当我想在执行到第2行的时候跳转到 第i行就需要使用jump</code><br><code>就如在当前函数内部调用其他函数</code><br><code>当其他函数执行完毕时会回到当前函数里面继续执行</code><br><strong>JCXZ AND JECXZ</strong><br><code>1.根据ECX,CX寄存器来判断跳转</code><br><code>2.根据 EFLAGS 来跳转 8个标志位来进行</code></p>
<p>#call and ret<br><code>call和ret是封装好的，是配对的，call之后必有ret</code><br><code>与jump一样</code></p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket-Ip地址转换</title>
    <url>/2022/01/02/SocketIP//</url>
    <content><![CDATA[<p><img src="https://i.bmp.ovh/imgs/2022/01/16056322709f2b74.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">int inet_pton(int af, const char *src, void *dst);</span><br><span class="line">const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</span><br></pre></td></tr></table></figure>
<p><strong>af 取值可选为 AF_INET 和 AF_INET6 ，即和 ipv4 和ipv6对应</strong><br><strong>支持IPv4和IPv6</strong></p>
<p><strong>其中inet_pton和inet_ntop不仅可以转换IPv4的in_addr，还可以转换IPv6的in6_addr.</strong><br>因此函数接口是void *addrptr. </p>
<h1 id="列"><a href="#列" class="headerlink" title="列:"></a>列:</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ip[] = <span class="string">&quot;2.3.4.5&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> server_ip[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//转换为网络字节序</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip, &amp;server_addr.sin_addr.s_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s_addr: %x\n&quot;</span>,server_addr.sin_addr.s_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s_addr from net to host : %x\n&quot;</span>, <span class="built_in">ntohl</span>(server_addr.sin_addr.s_addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//网络字节序转换为字符串</span></span><br><span class="line">    <span class="built_in">inet_ntop</span>(AF_INET, &amp;server_addr.sin_addr.s_addr, server_ip, <span class="built_in"><span class="keyword">sizeof</span></span>(server_ip));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server ip : %s\n&quot;</span>,server_ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出结果为:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s_addr: 5040302</span><br><span class="line">s_addr from net to host : 2030405</span><br><span class="line">server ip : 2.3.4.5</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程socket函数</title>
    <url>/2021/12/20/Socket//</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="socket创建流程图"><a href="#socket创建流程图" class="headerlink" title="socket创建流程图"></a>socket创建流程图</h1><p><img src="https://i.bmp.ovh/imgs/2022/01/70145893b5e39494.png"></p>
<h2 id="socket-函数"><a href="#socket-函数" class="headerlink" title="socket 函数"></a>socket 函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;  //* See NOTES </span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int socket(int domain, int type, int protocol);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>domain:</strong><br>    AF_INET 这是大多数用来产生socket的协议，使用TCP或UDP来传输，用IPv4的地址<br>    AF_INET6 与上面类似，不过是来用IPv6的地址<br>    AF_UNIX 本地协议，使用在Unix和Linux系统上，一般都是当客户端和服务器在同一台及其上的时候使用<br><strong>type:</strong><br>    SOCK_STREAM 这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类型，这个socket是使用TCP来进行传输。<br>    SOCK_DGRAM 这个协议是无连接的、固定长度的传输调用。该协议是不可靠的，使用UDP来进行它的连接。<br>    SOCK_SEQPACKET该协议是双线路的、可靠的连接，发送固定长度的数据包进行传输。必须把这个包完整的接受才能进行读取。<br>    SOCK_RAW socket类型提供单一的网络访问，这个socket类型使用ICMP公共协议。（ping、traceroute使用该协议）<br>    SOCK_RDM 这个类型是很少使用的，在大部分的操作系统上没有实现，它是提供给数据链路层使用，不保证数据包的顺序<br>protocol:<br>    传0 表示使用默认协议。<br>返回值：<br>    成功：返回指向新创建的socket的文件描述符，失败：返回-1，设置errno</p>
</blockquote>
<p><strong>socket()打开一个网络通讯端口，如果成功的话，就像open()一样返回一个文件描述符，应用程序可以像读写文件一样用read/write在网络上收发数据，如果socket()调用出错则返回-1。对于IPv4，domain参数指定为AF_INET。对于TCP协议，type参数指定为SOCK_STREAM，表示面向流的传输协议。如果是UDP协议，则type参数指定为SOCK_DGRAM，表示面向数据报的传输协议。protocol参数的介绍从略，指定为0即可。</strong></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2022/01/05/binary//</url>
    <content><![CDATA[<p><strong>查找某个值的位置</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[N],n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">    	<span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]==k)	<span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;a[mid]) r=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>查找第一个大于等于某个数的位置</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[N],n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_max</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">    	<span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		 <span class="keyword">if</span>(k&lt;=a[mid]) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>最后一个小于等于某个数的位置</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[N],n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_min</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">    	<span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		 <span class="keyword">if</span>(k&gt;=a[mid]) l=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><a href="https://nanti.jisuanke.com/t/T1560">题目链接</a></p>
<p>蒜头君手上有个长度为 n 的数组 <strong>A</strong>。由于数组实在太大了，所以蒜头君也不知道数组里面有什么数字，所以蒜头君会经常询问整数 x 是否在数组 <strong>A</strong> 中。</p>
<p><strong>输入格式</strong><br>第一行输入两个整数 n 和 m，分别表示数组的长度和查询的次数。</p>
<p>接下来一行有 n 个整数 a_ia<br>i<br>​<br> 。</p>
<p>接下来 mm 行，每行有 11 个整数 xx，表示蒜头君询问的整数。</p>
<p><strong>输出格式</strong><br>对于每次查询，如果可以找到，输出”YES”，否则输出”NO”。</p>
<p><strong>数据范围</strong><br>1 \le n, m \le 10^5, 0 \le x \le 10^61≤n,m≤10<br>5<br> ,0≤x≤10<br>6<br> 。</p>
<p>输出时每行末尾的多余空格，不影响答案正确性<br><strong>样例输入</strong></p>
<blockquote>
<p>10 5<br>1 1 1 2 3 5 5 7 8 9<br>0<br>1<br>4<br>9<br>10</p>
</blockquote>
<p><strong>样例输出</strong></p>
<blockquote>
<p>NO<br>YES<br>NO<br>YES<br>NO</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> q[N],n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==q[mid])   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;q[mid])    l=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>    r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)    cin &gt;&gt;q[i];</span><br><span class="line">    <span class="built_in">sort</span>(q,q+n);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">binary_search</span>(x))</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><a href="https://nanti.jisuanke.com/t/T1561">题目链接</a></p>
<p>蒜头君手上有个长度为 nn 的数组 AA。由于数组实在太大了，所以蒜头君也不知道数组里面有什么数字，所以蒜头君会经常询问在数组 AA 中，大于等于 xx 的最小值是多大？</p>
<p><strong>输入格式</strong><br>第一行输入两个整数 nn 和 mm，分别表示数组的长度和查询的次数。</p>
<p>接下来一行有 nn 个整数 a_ia<br>i<br>​<br> 。</p>
<p>接下来 mm 行，每行有 11 个整数 xx，表示蒜头君询问的整数。</p>
<p><strong>输出格式</strong><br>对于每次查询，如果可以找到，输出这个整数。</p>
<p>否则输出 -1−1。</p>
<p><strong>数据范围</strong><br>1 \le n, m \le 10^5, 0 \le x \le 10^61≤n,m≤10<br>5<br> ,0≤x≤10<br>6<br> 。</p>
<p>输出时每行末尾的多余空格，不影响答案正确性</p>
<p><strong>样例输入</strong></p>
<blockquote>
<p>10 5<br>1 1 1 2 3 5 5 7 8 9<br>0<br>1<br>4<br>9<br>10</p>
</blockquote>
<p><strong>样例输出</strong></p>
<blockquote>
<p>1<br>1<br>5<br>9<br>-1</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> q[N],n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=q[mid]) r=mid;</span><br><span class="line">        <span class="keyword">else</span>    l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)    cin &gt;&gt;q[i];</span><br><span class="line">    <span class="built_in">sort</span>(q,q+n);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="built_in">binary_search</span>(x);</span><br><span class="line">     <span class="keyword">if</span>(k&lt;n &amp;&amp; k&gt;=<span class="number">0</span> &amp;&amp; q[k]&gt;=x)</span><br><span class="line">         cout &lt;&lt; q[k] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://nanti.jisuanke.com/t/T1562">相关题目1</a><br><a href="https://nanti.jisuanke.com/t/T1563">相关题目2</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 类型转换</title>
    <url>/2021/11/29/TypeConversion//</url>
    <content><![CDATA[<h3 id="旧式转换与新式转换"><a href="#旧式转换与新式转换" class="headerlink" title="旧式转换与新式转换"></a>旧式转换与新式转换</h3><p><strong>旧式转型</strong> &emsp;C风格的强制类型<br>&emsp; &emsp; <strong>TYPE b=(TYPE)a</strong><br>    &emsp; &emsp;&emsp; &emsp;<strong>列如:<br>    &emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; int i=48<br>    &emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; char c=(char)i;</strong><br><strong>新式转型</strong>C++风格的类型转换提供了4种类型转换操作符来应对不同场合的应用。<br>格式：<br>        <strong>TYPE b = 类型操作符<TYPE>(a)<br>       类型操作符</strong>= <font color=Red>static_cast<br>             &emsp; &emsp; &emsp; &emsp;&emsp;  reinterpreter_cast<br>    &emsp; &emsp;    &emsp; &emsp;&emsp;   dynamic_cast<br>       &emsp; &emsp;&emsp;  &emsp; &emsp;&emsp; const_cast</font></p>
<h1 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h1><p> 静态类型转换（斯文的劝导，温柔的转换）。如int转换成char<br>&emsp; &emsp;&emsp; <strong>主要用法：</strong><br>&emsp; &emsp;&emsp; &emsp; &emsp;&emsp; 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。上行指针或引用(派生类到基类)转换安全，下行不安全<br>&emsp; &emsp;&emsp; &emsp; &emsp;&emsp; 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。<br>&emsp; &emsp;&emsp; &emsp; &emsp;&emsp; 把空指针转换成目标类型的空指针。<br>&emsp; &emsp;&emsp; &emsp; &emsp;&emsp; 把任何类型的表达式转换成void类型。</p>
<p><em>代码示例:</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;喵喵瞄&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;汪汪汪&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种情况  父子类之间的类型转换</span></span><br><span class="line">	Dog* dog1 = <span class="keyword">new</span> <span class="built_in">Dog</span>();</span><br><span class="line">	Animal* a1 = <span class="keyword">static_cast</span>&lt;Animal*&gt;(dog1); <span class="comment">//子类的指针转型到父类指针</span></span><br><span class="line"></span><br><span class="line">	Dog* dog1_1 = <span class="keyword">static_cast</span>&lt;Dog*&gt;(a1);     <span class="comment">//父类的指针转型到子类的指针</span></span><br><span class="line">	Cat* cat1 = <span class="keyword">static_cast</span>&lt;Cat*&gt;(a1);       <span class="comment">//父子到子类，有风险，这样时不行的，会出问题</span></span><br><span class="line"></span><br><span class="line">	Dog dog2;</span><br><span class="line">	Animal&amp; a2 = <span class="keyword">static_cast</span>&lt;Animal&amp;&gt;(dog2); <span class="comment">//子类的引用转型到父类的引用</span></span><br><span class="line">	Dog &amp;dog2_2 = <span class="keyword">static_cast</span>&lt;Dog&amp;&gt;(a2);     <span class="comment">//父类到子类引用</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种 基本类型的转换</span></span><br><span class="line">	<span class="keyword">int</span>  kk = <span class="number">234</span>;</span><br><span class="line">	<span class="keyword">char</span> cc = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(kk);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第三种 把空指针转换成目标类型的空指针。</span></span><br><span class="line">	<span class="keyword">int</span>* p = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(<span class="literal">NULL</span>);</span><br><span class="line">	Dog* dp = <span class="keyword">static_cast</span>&lt;Dog*&gt;(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第四种 把任何类型的表达式转换成void类型</span></span><br><span class="line">	<span class="keyword">int</span>* pi = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">void</span>* vp = <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(pi);</span><br><span class="line">	vp = pi;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h1><p>重新解释类型(挂羊头，卖狗肉) 不同类型间的互转，数值与指针间的互转</p>
<p>&emsp; &emsp;&emsp;用法：<br>&emsp; &emsp;&emsp;&emsp; &emsp;&emsp; <strong>TYPE b = reinterpret_cast <TYPE> ( a )<br>&emsp; &emsp;&emsp;&emsp; &emsp;&emsp;TYPE</strong>必须是一个指针、引用、算术类型、函数指针.</p>
<p><strong>忠告</strong>:<em>滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。</em></p>
<p><strong>注!</strong> :<strong><font color=Red>不同类型指针转换不能使用static_cast</strong></font><br><em>代码示例:</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;动物叫&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;喵喵瞄&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;汪汪汪&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//用法一   数值与指针之间的转换</span></span><br><span class="line">	<span class="keyword">int</span>* p = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(<span class="number">0x99999</span>);</span><br><span class="line">	<span class="keyword">int</span> val = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>&gt;(p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//用法二  不同类型指针和引用之间的转换</span></span><br><span class="line">	Dog  dog1;</span><br><span class="line">	Animal* a1 = &amp;dog1;</span><br><span class="line">	a1-&gt;<span class="built_in">cry</span>();</span><br><span class="line"></span><br><span class="line">	Dog* dog1_p = <span class="keyword">reinterpret_cast</span>&lt;Dog*&gt;(a1);</span><br><span class="line">	Dog* dog2_p = <span class="keyword">static_cast</span>&lt;Dog*&gt;(a1);   <span class="comment">//如果能用static_cast ，static_cast 优先</span></span><br><span class="line"></span><br><span class="line">	Cat* cat2_p = <span class="keyword">reinterpret_cast</span>&lt;Cat*&gt;(dog1_p);</span><br><span class="line"></span><br><span class="line">	Animal&amp; a2 = dog1;</span><br><span class="line">	Dog&amp; dog3 = <span class="keyword">reinterpret_cast</span>&lt;Dog&amp;&gt;(a2);<span class="comment">//引用强转用法</span></span><br><span class="line"></span><br><span class="line">	dog1_p-&gt;<span class="built_in">cry</span>();</span><br><span class="line">	dog2_p-&gt;<span class="built_in">cry</span>();</span><br><span class="line"></span><br><span class="line">	cat2_p-&gt;<span class="built_in">cry</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h1><p><strong>动态类型转换</strong><br>&emsp; &emsp;&emsp;&emsp; &emsp;&emsp;将一个基类对象指针cast到继承类指针，<strong>dynamic_cast</strong> 会根据基类指针是否真正指向继承类指针来做相应处理。失败返回null，成功返回正常cast后的对象指针；<br>&emsp; &emsp;&emsp;&emsp; &emsp;&emsp;将一个基类对象引用cast 继承类对象，<strong>dynamic_cast</strong> 会根据基类对象是否真正属于继承类来做相应处理。失败抛出异常bad_cast<br>注意：<strong>dynamic_cast</strong>在将父类cast到子类时，父类必须要有虚函数一起。</p>
<p><em>代码示例:</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;喵喵瞄&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;爬爬树&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;汪汪汪&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;溜达溜达&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">animalPlay</span><span class="params">(Animal&amp; animal)</span> </span>&#123;</span><br><span class="line">	animal.<span class="built_in">cry</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Dog&amp; pDog = <span class="keyword">dynamic_cast</span>&lt;Dog&amp;&gt;(animal);</span><br><span class="line">		pDog.<span class="built_in">play</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in"><span class="keyword">catch</span></span> (std::bad_cast bc) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;不是狗，那应该是猫&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Cat&amp; pCat = <span class="keyword">dynamic_cast</span>&lt;Cat&amp;&gt;(animal);</span><br><span class="line">		pCat.<span class="built_in">play</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in"><span class="keyword">catch</span></span> (std::bad_cast bc) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;不是猫，那应该是上面的狗&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">animalPlay</span><span class="params">(Animal* animal)</span> </span>&#123;</span><br><span class="line">	animal-&gt;<span class="built_in">cry</span>();</span><br><span class="line"></span><br><span class="line">	Dog* pDog = <span class="keyword">dynamic_cast</span>&lt;Dog*&gt;(animal);</span><br><span class="line">	<span class="keyword">if</span> (pDog) &#123;</span><br><span class="line">		pDog-&gt;<span class="built_in">play</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;<span class="comment">//pDog == NULL</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;不是狗，别骗我！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Cat* pCat = <span class="keyword">dynamic_cast</span>&lt;Cat*&gt;(animal);</span><br><span class="line">	<span class="keyword">if</span> (pCat) &#123;</span><br><span class="line">		pCat-&gt;<span class="built_in">play</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;<span class="comment">//pDog == NULL</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;不是猫，别骗我！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Dog* dog1 = <span class="keyword">new</span> <span class="built_in">Dog</span>();</span><br><span class="line">	Animal* a1 = dog1;</span><br><span class="line"></span><br><span class="line">	Dog dog2;</span><br><span class="line">	<span class="built_in">animalPlay</span>(dog2);</span><br><span class="line"></span><br><span class="line">	Cat* cat1 = <span class="keyword">new</span> <span class="built_in">Cat</span>();</span><br><span class="line">	Animal* a2 = cat1;</span><br><span class="line"></span><br><span class="line">	Cat cat2;</span><br><span class="line">	<span class="built_in">animalPlay</span>(cat2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h1><p><strong>去const属性.(仅针对于指针和引用)</strong></p>
<p><em>代码示例:</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//对指针去掉cost 重新赋值</span></span><br><span class="line">	<span class="comment">//char* p1 = const_cast&lt;char *&gt;(p);</span></span><br><span class="line">	<span class="comment">//p1[0] = &#x27;A&#x27;;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//直接去掉const修改</span></span><br><span class="line">	<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(p)[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//字符串数组</span></span><br><span class="line">	<span class="comment">//char p[] = &quot;12345678&quot;;</span></span><br><span class="line">	<span class="comment">//demo(p);  //合情合理</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//常量字符串不能去掉const 修改</span></span><br><span class="line">	<span class="comment">//警告： 在去掉常量限定符之前，保证指针所指向的内存能够修改，不能修改则会引起异常。</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* cp = <span class="string">&quot;987654321&quot;</span>;</span><br><span class="line">	<span class="built_in">demo</span>(cp);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型转换使用建议"><a href="#类型转换使用建议" class="headerlink" title="类型转换使用建议"></a>类型转换使用建议</h2><blockquote>
<p><strong>1.static_cast静态类型转换，编译的时c++编译器会做编译时的类型检查；隐式转换；<br>基本类型转换，父子类之间合理转换<br>    2.若不同类型之间，进行强制类型转换，用reinterpret_cast&lt;&gt;() 进行重新解释<br>       建  议：<br>C语言中  能隐式类型转换的，在c++中可用 static_cast&lt;&gt;()进行类型转换。因C++编译器在编译检查一般都能通过；C语言中不能隐式类型转换的，在c++中可以用 reinterpret_cast&lt;&gt;() 进行强制类型解释。<br>总结：static_cast&lt;&gt;()和reinterpret_cast&lt;&gt;() 基本上把C语言中的 强制类型转换给覆盖，注意reinterpret_cast&lt;&gt;()很难保证移植性。<br>3.dynamic_cast&lt;&gt;()，动态类型转换，安全的虚基类和子类之间转换；运行时类型检查<br>    4.const_cast&lt;&gt;()，去除变量的只读属性<br>最后的忠告：程序员必须清楚的知道: 要转的变量，类型转换前是什么类型，类型转换                后是什么类型，转换后有什么后果。</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>推箱子小游戏</title>
    <url>/2021/11/29/Sokoban//</url>
    <content><![CDATA[<p>开发环境:Vs2017 + EasyX<br><a href="https://spaceout.cn/2021/11/29/EasyX%E5%9B%BE%E5%BD%A2%E5%BA%93%E5%AE%89%E8%A3%85/">EasyX安装教程</a></p>
<p><strong>该程序分为4个模块分别为：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/3013c35c53c241cabe9c15e8d8d75d81.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAX1NwYWNlXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="推箱子模块"></p>
<p><a href="https://pan.baidu.com/s/1MZv8pDBXdNDbXxuAAPSM-A">素材链接提取码：2syq</a> </p>
<h1 id="地图初始化"><a href="#地图初始化" class="headerlink" title="地图初始化"></a>地图初始化</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;graphics.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RATIO 61</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCREEN_WIDTH 960 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCREEN_HEIGHT 768</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINE 9 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLUMN 12</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> START_X 100 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> START_Y 150</span></span><br><span class="line"></span><br><span class="line">IMAGE images[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*游戏地图*/</span> </span><br><span class="line"><span class="keyword">int</span> map[LINE][COLUMN] = &#123; &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, </span><br><span class="line">&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, </span><br><span class="line">&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span> &#125;, </span><br><span class="line">&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span> &#125;, </span><br><span class="line">&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span> &#125;, </span><br><span class="line">&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span> &#125;, </span><br><span class="line">&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span> &#125;, </span><br><span class="line">&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; </span><br><span class="line">	IMAGE bg_img; </span><br><span class="line">	<span class="comment">//搭台唱戏 </span></span><br><span class="line">	<span class="built_in">initgraph</span>(SCREEN_WIDTH, SCREEN_HEIGHT); </span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;bg_img, _T(<span class="string">&quot;blackground.bmp&quot;</span>), SCREEN_WIDTH, SCREEN_HEIGHT, <span class="literal">true</span>); </span><br><span class="line">	<span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;bg_img);</span><br><span class="line"><span class="comment">//加载道具图标 </span></span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;images[<span class="number">0</span>], _T(<span class="string">&quot;wall.bmp&quot;</span>), RATIO, RATIO, <span class="literal">true</span>);</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;images[<span class="number">1</span>], _T(<span class="string">&quot;floor.bmp&quot;</span>), RATIO, RATIO, <span class="literal">true</span>); 		</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;images[<span class="number">2</span>], _T(<span class="string">&quot;des.bmp&quot;</span>), RATIO, RATIO, <span class="literal">true</span>); </span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;images[<span class="number">3</span>], _T(<span class="string">&quot;man.bmp&quot;</span>), RATIO, RATIO, <span class="literal">true</span>); </span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;images[<span class="number">4</span>], _T(<span class="string">&quot;box.bmp&quot;</span>), RATIO, RATIO, <span class="literal">true</span>); </span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;images[<span class="number">5</span>], _T(<span class="string">&quot;box.bmp&quot;</span>), RATIO, RATIO, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; LINE; i++)&#123; </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; COLUMN; j++)&#123; </span><br><span class="line">			<span class="built_in">putimage</span>(START_X+j*RATIO, START_Y+i*RATIO, &amp;images[map[i][j]]); </span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">isGameOver</span>())&#123; </span><br><span class="line">					<span class="built_in">gameOverScene</span>(&amp;bg_img); </span><br><span class="line">					quit = <span class="literal">true</span>; </span><br><span class="line">				&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="热键控制"><a href="#热键控制" class="headerlink" title="热键控制"></a>热键控制</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;</span> </span></span><br><span class="line"><span class="comment">//控制键 上、下、左、右 控制方向，&#x27;q&#x27; 退出 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY_UP <span class="meta-string">&#x27;w&#x27;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY_LEFT <span class="meta-string">&#x27;a&#x27;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY_RIGHT <span class="meta-string">&#x27;d&#x27;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY_DOWN <span class="meta-string">&#x27;s&#x27;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY_QUIT <span class="meta-string">&#x27;q</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//游戏环节 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">bool quit = false; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">do &#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	if(_kbhit())&#123; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	//玩家按键 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	char ch = _getch(); </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		if(ch == KEY_UP)&#123; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			gameControl(UP); </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		&#125;else if(ch == KEY_DOWN)&#123; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			gameControl(DOWN); </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		&#125;else if(ch == KEY_LEFT)&#123; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			gameControl(LEFT); </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		&#125;else if(ch == KEY_RIGHT)&#123; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			gameControl(RIGHT); </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		&#125;else if(ch == KEY_QUIT)&#123; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			quit = true; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	Sleep(100); </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;while(quit==false); //!quit</span></span></span><br></pre></td></tr></table></figure>
<h3 id="推箱子控制"><a href="#推箱子控制" class="headerlink" title="推箱子控制"></a>推箱子控制</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/********************************************** </span></span><br><span class="line"><span class="comment">*实现游戏四个方向（上、下、左、右）的控制 </span></span><br><span class="line"><span class="comment">*输入： * direct - 人前进方向</span></span><br><span class="line"><span class="comment">*输出： 无 </span></span><br><span class="line"><span class="comment">***********************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gameControl</span><span class="params">(<span class="keyword">enum</span> _DIRECTION direct)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">POS</span> <span class="title">next_pos</span> =</span> man; </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">POS</span> <span class="title">next_next_pos</span> =</span> man; </span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span>(direct)&#123; </span><br><span class="line">		<span class="keyword">case</span> UP: </span><br><span class="line">			next_pos.x--; </span><br><span class="line">			next_next_pos.x-=<span class="number">2</span>; </span><br><span class="line">			<span class="keyword">break</span>; </span><br><span class="line">		<span class="keyword">case</span> DOWN: </span><br><span class="line">			next_pos.x++; </span><br><span class="line">			next_next_pos.x+=<span class="number">2</span>; </span><br><span class="line">			<span class="keyword">break</span>; </span><br><span class="line">		<span class="keyword">case</span> LEFT: </span><br><span class="line">			next_pos.y--; </span><br><span class="line">			next_next_pos.y-=<span class="number">2</span>; </span><br><span class="line">			<span class="keyword">break</span>; </span><br><span class="line">		<span class="keyword">case</span> RIGHT: </span><br><span class="line">			next_pos.y++; </span><br><span class="line">			next_next_pos.y+=<span class="number">2</span>; </span><br><span class="line">			<span class="keyword">break</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//宏展开 next_pos.x&gt;=0 &amp;&amp; next_pos.x&lt;LINE &amp;&amp; next_pos.y&gt;=0 &amp;&amp; next_pos.y &lt;COLUMN</span></span><br><span class="line">	<span class="keyword">if</span>( <span class="built_in">isValid</span>(next_pos) &amp;&amp; map[next_pos.x][next_pos.y] == FLOOR )&#123;<span class="comment">// 人的前方是地板</span></span><br><span class="line">		<span class="built_in">changeMap</span>(&amp;next_pos, MAN); <span class="comment">//小人前进一格 	</span></span><br><span class="line">		<span class="built_in">changeMap</span>(&amp;man, FLOOR);</span><br><span class="line">		<span class="built_in">changeMap</span>(&amp;man, FLOOR); </span><br><span class="line">		man = next_pos;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(map[next_next_pos.x][next_next_pos.y] == BOX_DES)&#123; </span><br><span class="line">			<span class="built_in">changeMap</span>(&amp;next_next_pos, HIT); 	</span><br><span class="line">			<span class="built_in">changeMap</span>(&amp;next_pos, MAN); <span class="comment">//小人前进一格 </span></span><br><span class="line">			<span class="built_in">changeMap</span>(&amp;man, FLOOR); man = next_pos; </span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="游戏结束"><a href="#游戏结束" class="headerlink" title="游戏结束"></a>游戏结束</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/********************************************** </span></span><br><span class="line"><span class="comment">*判断游戏是否结束，如果不存在任何一个箱子目的地，就代表游戏结束 </span></span><br><span class="line"><span class="comment">*输入： 无 </span></span><br><span class="line"><span class="comment">*返回值： * true - 游戏结束 false - 游戏继续 </span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isGameOver</span><span class="params">()</span></span>&#123; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; LINE; i++)&#123; </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; COLUMN; j++)&#123; </span><br><span class="line">			<span class="keyword">if</span>(map[i][j] == BOX_DES) </span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">*游戏结束场景，在玩家通关后显示 </span></span><br><span class="line"><span class="comment">*输入： * bg - 背景图片变量的指针 </span></span><br><span class="line"><span class="comment">*返回值： 无 </span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gameOverScene</span><span class="params">(IMAGE *bg)</span></span>&#123; </span><br><span class="line">	<span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, bg); </span><br><span class="line">	<span class="built_in">settextcolor</span>(WHITE); </span><br><span class="line">	RECT rec = &#123;<span class="number">0</span>, <span class="number">0</span>, SCREEN_WIDTH, SCREEN_HEIGHT&#125;; </span><br><span class="line">	<span class="built_in">settextstyle</span>(<span class="number">20</span>, <span class="number">0</span>, _T(<span class="string">&quot;宋体&quot;</span>)); </span><br><span class="line">	<span class="built_in">drawtext</span>(_T(<span class="string">&quot;恭喜您~\n 已通关！&quot;</span>), &amp;rec, DT_CENTER | DT_VCENTER | DT_SINGLELINE); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb调试 与 coredump</title>
    <url>/2022/01/28/gdb//</url>
    <content><![CDATA[<p><strong><a href="https://spaceout.cn/2022/01/27/MakeFile/">该文章需要用到MakeFile点击阅读</a></strong></p>
<h1 id="安装-gdb"><a href="#安装-gdb" class="headerlink" title="安装 gdb"></a>安装 gdb</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.wget http://ftp.gnu.org/gnu/gdb/gdb-8.1.1.tar.gz</span><br><span class="line">2.tar -zxvf gdb-8.1.1.tar.gz</span><br><span class="line">3.cd gdb-8.1.1</span><br><span class="line">4. ./configure</span><br><span class="line">5.make</span><br><span class="line">6.make install </span><br></pre></td></tr></table></figure>

<h1 id="启动gdb"><a href="#启动gdb" class="headerlink" title="启动gdb"></a>启动gdb</h1><blockquote>
<p>gdb <strong>hello</strong> <em>hello是可执行文件，这里用的是MakeFile里面生成的</em></p>
</blockquote>
<p>然后就可以进入命令行操作，和 Shell 一样,gdb 支持命令补全。输入几个字母，按Tab键，gdb 会补全命令。按两次Tab ，会提示所有可能的命令。<br>另外，其还支持命令缩写，如， h 代表 help ，</p>
<h2 id="常用命令如下"><a href="#常用命令如下" class="headerlink" title="常用命令如下:"></a>常用命令如下:</h2><h4 id="获取帮组命令-help"><a href="#获取帮组命令-help" class="headerlink" title="获取帮组命令 help"></a>获取帮组命令 help</h4><p>gdb将命令分为12个大类，使用命令： “help 子类别”可以查看没类下面的详细帮助。</p>
<p>如： <strong>help breakpoints</strong></p>
<h4 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h4><p><strong>break</strong> 命令用于设置断点,命令接受行号或者函数名作为参数。<br><img src="https://i.bmp.ovh/imgs/2022/01/63233cb757175033.png"><br><strong>break</strong>也可设置条件断点：<br><br>如： <strong>break sayHello if count&lt;1 **<br><br>使用</strong>info break** 可以查看断点<br></p>
<p>使用 <strong>clear</strong> 可以清除断点<br></p>
<h4 id="运行程序和单步执行"><a href="#运行程序和单步执行" class="headerlink" title="运行程序和单步执行"></a>运行程序和单步执行</h4><p>设置完断点后，就可以运行调试程序了，使用run命令（缩写为 r)运行程序至断点。<br><img src="https://i.bmp.ovh/imgs/2022/01/01a8fdb66565861f.png"><br><br>此时，程序中断，gdb 等待用户发出下一步操作的指令。设用<strong>next</strong> 命令(缩写为 <strong>n</strong>)单步执行程序。也可以指定一个数字。下面这条命令让gdb 连续执行两行，然后停下。</p>
<p>如果想继续运行，可以使用<strong>continue <strong>命令(缩写为</strong> c</strong> )指导 gdb 继续运行程序，直至遇到下一个断点。<br>如果想继续单步执行，可以继续使用 <strong>next</strong>,也是以使用 <strong>step</strong> (缩写为 <strong>s</strong>), <strong>step</strong> 和 <strong>next</strong> 的最大的区别在于，step 遇到函数是会进入到内部，而next 不会进入内部.</p>
<h4 id="监视变量"><a href="#监视变量" class="headerlink" title="监视变量"></a>监视变量</h4><p>调试程序最基本的需求就是监视变量的值，可以使用 <strong>print</strong> 命令（缩写为 <strong>p</strong>) 显示指定变量的值。<br><img src="https://i.bmp.ovh/imgs/2022/01/ba38cd934b758c19.png"><br><br>如果要时刻监视某个变量的值，那么每次使用 <strong>print</strong> 就不方便。比较人性化的是,gdb 提供了<strong>watch</strong> 命令，用于设置另一种断点：“观察点”。<br>用法是：  <strong>watch</strong> 变量名或表达式作为参数，一但值发生变化，就停下来。</p>
<h4 id="临时修改变量"><a href="#临时修改变量" class="headerlink" title="临时修改变量"></a>临时修改变量</h4><p>当某些特殊情况下，我们想让程序进入一些特殊的流程时，gdb允许用户在程序运行时改变变量的值，通过 <strong>set var</strong> 命令实现这一点.<br><br><img src="https://i.bmp.ovh/imgs/2022/01/c62a4079d145c0aa.png"><br></p>
<h4 id="查看堆栈情况"><a href="#查看堆栈情况" class="headerlink" title="查看堆栈情况"></a>查看堆栈情况</h4><p>每次程序调用一个函数，函数的地址、参数、函数内部变量都会被压入“栈”(<strong>Stack</strong>) 中，运行时堆栈信息对于程序员非常重要，使用 “bt”命令可以看到当前运行时栈的情况。<br><br><img src="https://i.bmp.ovh/imgs/2022/01/700175938a716a45.png"><br></p>
<h4 id="退出-gdb"><a href="#退出-gdb" class="headerlink" title="退出 gdb"></a>退出 gdb</h4><p>调试完毕，使用<strong>quit</strong>命令(缩写为<strong>q</strong>) 退出 gdb程序。</p>
<h1 id="Coredump-调试"><a href="#Coredump-调试" class="headerlink" title="Coredump 调试"></a>Coredump 调试</h1><h4 id="coredump是什么？"><a href="#coredump是什么？" class="headerlink" title="coredump是什么？"></a>coredump是什么？</h4><p>   <strong>程序异常退出时，会产生一个core文件，该文件记录了程序运行时的内存，<br>   寄存器状态，堆栈指针，内存管理信息还有各种函数调用堆栈信息等，我们<br>   可以理解为是程序工作当前状态存储生成的一个文件，通过工具分析这个文<br>   件，我们可以定位到程序异常退出的时候对应的堆栈调用等信息，找出问题<br>   所在并进行及时解决。</strong></p>
<h4 id="前期设置"><a href="#前期设置" class="headerlink" title="前期设置"></a>前期设置</h4><blockquote>
<p>1)设置core文件生成的目录，其中%e表示程序文件名，%p表示进程ID，<br><br>否则会在程序的当前目录生成dore文件；<br><br>**echo /data/coredump/core.%e.%p &gt;/proc/sys/kernel/core_pattern **  <br><br>2) 当前执行程序的用户对core目录有写权限且有足够的空间存储core文件；<br><br>3) 生成不受限制的core文件；<br><br><strong>ulimit  -c unlimited</strong><br></p>
</blockquote>
<h4 id="什么情况下会导致程序异常退出"><a href="#什么情况下会导致程序异常退出" class="headerlink" title="什么情况下会导致程序异常退出"></a>什么情况下会导致程序异常退出</h4><p>   非法指针的访问，堆栈溢出 </p>
<p><strong>测试代码:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span> <span class="params">(<span class="keyword">int</span> *p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> y=*p;</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">func</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如何调试"><a href="#如何调试" class="headerlink" title="如何调试"></a>如何调试</h4><blockquote>
<ol>
<li>编译的时候添加-g选项，增加调试信息<br></li>
<li><strong>gdb program core_file</strong><br></li>
</ol>
</blockquote>
<p><strong>bt或者where查看调用栈信息</strong></p>
<p>如果你要查看某一层的信息，你需要切换当前的栈，一般来说，程序停止时，最顶层的栈就是当前栈，如果你要查看栈下面层的详细信息，首先要做的是切换当前栈。</p>
<p><strong>frame</strong> &lt; n&gt; <br><br><strong>f</strong> &lt; n&gt; <br><br>n是一个从0开始的整数，是栈中的层编号。比如：<strong>frame</strong> 0，表示栈顶，<strong>frame</strong> 1，表示栈的第二层。<br></p>
<p><strong>up</strong> &lt; n&gt;<br><br>表示向栈的上面移动n层，可以不打n，表示向上移动一层。 <br></p>
<p><strong>down</strong> &lt; n&gt; <br><br>表示向栈的下面移动n层，可以不打n，表示向下移动一层。 <br><br>上面的命令，都会打印出移动到的栈层的信息。如果你不想让其打出信息。你可以使用这三个命令：<br></p>
<p><strong>select-frame</strong> &lt; n&gt; 对应于 frame 命令。<br><br><strong>up-silently</strong> &lt; n&gt; 对应于 up 命令。<br><br><strong>down-silently</strong> &lt; n&gt; 对应于 down 命令。<br></p>
<p><strong>查看当前栈层的信息，你可以用以下GDB命令：</strong><br></p>
<p><strong>frame</strong> 或 <strong>f</strong> <br><br>会打印出这些信息：栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数执行到的语句。<br></p>
<p><strong>info frame</strong><br><br><strong>info f</strong><br><br>这个命令会打印出更为详细的当前栈层的信息，只不过，大多数都是运行时的内内地址。比如：函数地址，调用函数的地址，被调用函数的地址，目前的函数是由什么样的程序语言写成的、函数参数地址及值、局部变量的地址等等。如：<br><br><img src="https://i.bmp.ovh/imgs/2022/01/372c861c5c84d0c9.png"></p>
<p><strong>info args</strong><br><br>打印出当前函数的参数名及其值。<br></p>
<p><strong>info locals</strong><br><br>打印出当前函数中所有局部变量及其值。<br></p>
<h4 id="另类的方式？打印堆栈"><a href="#另类的方式？打印堆栈" class="headerlink" title="另类的方式？打印堆栈"></a>另类的方式？打印堆栈</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//信号钩子函数，获取栈信息，然后在日志中打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_segv</span><span class="params">(<span class="keyword">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *array[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    <span class="keyword">char</span> **strings;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">signal</span>(signum, SIG_DFL); <span class="comment">/* 还原默认的信号处理handler */</span></span><br><span class="line"></span><br><span class="line">    size = <span class="built_in">backtrace</span> (array, <span class="number">100</span>);</span><br><span class="line">    strings = (<span class="keyword">char</span> **)<span class="built_in">backtrace_symbols</span> (array, size);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;Launcher received SIG: %d Stack trace:\n&quot;</span>, signum);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;%d %s \n&quot;</span>,i,strings[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span> (strings);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在main 函数中加入：</span></span><br><span class="line"> <span class="built_in">signal</span>(SIGSEGV, handle_segv); <span class="comment">// SIGSEGV    11       Core Invalid memory reference</span></span><br><span class="line"> <span class="built_in">signal</span>(SIGABRT, handle_segv); <span class="comment">// SIGABRT     6       Core Abort signal from</span></span><br></pre></td></tr></table></figure>
<p>注意：编译时一定要带上 -g 选项 </p>
<p>使用<strong>addr2line</strong>命令检测:<br><strong>addr2line -a 0x4007fa -e demo_log</strong></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>差分数组</title>
    <url>/2022/01/13/difference//</url>
    <content><![CDATA[<p><strong>一维数组差分数组的构建</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    b[l] += x;</span><br><span class="line">    b[r + <span class="number">1</span>] -= x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>二维数组差分数组的构建</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	ds[x1][y1] += x;</span><br><span class="line">    ds[x2+<span class="number">1</span>][y1] -=x;</span><br><span class="line">    ds[x1][y2+<span class="number">1</span>] -=x;</span><br><span class="line">    ds[x2+<span class="number">1</span>][y2+<span class="number">1</span>] +=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h1><p><a href="http://oj.hzjingma.com/p/40?view=classic">题目链接</a></p>
<p>输入一个长度为nn的整数序列。</p>
<p>接下来输入q次操作，每个操作包含三个整数l, r, xl,r,x，表示将序列中[l, r][l,r]之间的每个数加上x。</p>
<p>请你输出进行完所有操作后的序列。</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><hr>
<p>第一行包含两个整数nn和qq。</p>
<p>第二行包含nn个整数，表示整数序列。</p>
<p>接下来q行，每行包含三个整数l，r，x，l，r，x，表示一个操作。</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><hr>
<p>共一行，包含n个整数，表示最终序列。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><blockquote>
<p>6 3<br>1 2 3 4 5 6<br>1 6 1<br>1 1 2<br>2 2 -3</p>
</blockquote>
<h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><blockquote>
<p>4 0 4 5 6 7</p>
</blockquote>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><hr>
<p><strong>数据规模</strong></p>
<p>1≤n≤1000,1≤q≤2000,1≤l≤r≤n,a{ij} ,x都在intint范围内</p>
<p>对于100%的数据</p>
<p>1≤n≤100000,1≤q≤200000,1≤l≤r≤n,a{ij},x都在intint范围内</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> q[N],n;</span><br><span class="line"><span class="keyword">int</span> ds[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	ds[l]+=x;</span><br><span class="line">    ds[r+<span class="number">1</span>]-=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="built_in">insert</span>(i,i,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    	<span class="keyword">int</span> l,r,x;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r&gt;&gt;x;</span><br><span class="line">        <span class="built_in">insert</span>(l,r,x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) q[i]=q[i<span class="number">-1</span>]+ds[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cout &lt;&lt; q[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h1><p><a href="http://oj.hzjingma.com/p/41?view=classic">题目链接</a><br>有一个nn行mm列的整数矩阵AA，wlxsq有qq个操作，</p>
<p>每个操作包含五个整数x_1, y_1, x_2, y_2, cx<br>1<br>​<br> ,y<br>1<br>​<br> ,x<br>2<br>​<br> ,y<br>2<br>​<br> ,c，其中(x_1, y_1)(x<br>1<br>​<br> ,y<br>1<br>​<br> )和(x_2, y_2)(x<br>2<br>​<br> ,y<br>2<br>​<br> )表示一个子矩阵的左上角坐标和右下角坐标。</p>
<p>每个操作都要将选中的子矩阵中的每个元素的值加上cc。</p>
<p>请你将进行完所有操作后的矩阵输出。</p>
<p>输入<br>第一行包含整数n,m,qn,m,q。</p>
<p>接下来nn行，每行包含mm个整数，表示整数矩阵。</p>
<p>接下来qq行，每行包含55个整数x_1, y_1, x_2, y_2, cx<br>1<br>​<br> ,y<br>1<br>​<br> ,x<br>2<br>​<br> ,y<br>2<br>​<br> ,c，表示一个操作。</p>
<p>输出<br>共nn 行，每行 mm 个整数，表示所有操作进行完毕后的最终矩阵。</p>
<p>样例<br>输入复制<br>3 4 3<br>1 2 3 4<br>5 6 7 8<br>9 10 11 12<br>1 1 2 2 1<br>1 3 2 3 2<br>3 1 3 4 1<br>输出复制<br>2 3 5 4<br>6 7 9 8<br>10 11 12 13<br>提示<br>数据规模</p>
<p>对于100%100%的数据</p>
<p>1≤n,m≤1000,1≤q≤100000, 1≤x1≤x2≤n,1≤y1≤y2≤m,−10^8≤c≤10^8<br>1≤n,m≤1000,1≤q≤100000,1≤x1≤x2≤n,1≤y1≤y2≤m,−10<br>8<br> ≤c≤10<br>8</p>
<p>xx都在intint范围内</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> q[N][N],n,m;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ds[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	ds[x1][y1] += x;</span><br><span class="line">    ds[x2+<span class="number">1</span>][y1] -=x;</span><br><span class="line">    ds[x1][y2+<span class="number">1</span>] -=x;</span><br><span class="line">    ds[x2+<span class="number">1</span>][y2+<span class="number">1</span>] +=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ts;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;ts;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        	<span class="keyword">int</span> x;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            <span class="built_in">insert</span>(i,j,i,j,x);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(ts--)&#123;</span><br><span class="line">    	<span class="keyword">int</span> x1,y1,x2,y2,c;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;</span><br><span class="line">        <span class="built_in">insert</span>(x1,y1,x2,y2,c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        	q[i][j]=q[i<span class="number">-1</span>][j]+q[i][j<span class="number">-1</span>]-q[i<span class="number">-1</span>][j<span class="number">-1</span>]+ds[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">    		cout &lt;&lt; q[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">          cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer II 001. 整数除法</title>
    <url>/2022/01/26/offer001//</url>
    <content><![CDATA[<p>给定两个整数 a 和 b ，求它们的除法的商 a/b ，要求不得使用乘号 ‘*’、除号 ‘/‘ 以及求余符号 ‘%’ 。</p>
<p> </p>
<p><strong>注意：</strong></p>
<ul>
<li>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2</li>
<li>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231−1]。本题中，如果除法结果溢出，则返回 231 − 1
 </li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入：</strong>a = 15, b = 2<br><br><strong>输出</strong>：7<br><br><strong>解释：</strong>15/2 = truncate(7.5) = 7</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><strong>输入</strong>：a = 7, b = -3<br><br><strong>输出</strong>：-2<br><br><strong>解释：</strong>7/-3 = truncate(-2.33333..) = -2<br></p>
</blockquote>
<p><strong>示例 3：</strong></p>
<blockquote>
<p><strong>输入：</strong>a = 0, b = 1<br><br><strong>输出：</strong>0<br></p>
</blockquote>
<p><strong>示例 4：</strong><br></p>
<blockquote>
<p><strong>输入：</strong>a = 1, b = 1<br><br><strong>输出：</strong>1
 </p>
</blockquote>
<p><strong>提示:</strong></p>
<p>-231 &lt;= a, b &lt;= 231 - 1<br>b != 0</p>
<p><strong>代码：</strong><br></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(a==INT_MIN &amp;&amp; b==<span class="number">-1</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">		<span class="keyword">if</span>(a==INT_MIN &amp;&amp; b==<span class="number">1</span>)  <span class="keyword">return</span> INT_MIN;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">bool</span> sign = (a&gt;<span class="number">0</span>)^(b&gt;<span class="number">0</span>)?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> da=<span class="built_in">abs</span>(a),db=<span class="built_in">abs</span>(b),res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">			<span class="keyword">if</span>((da&gt;&gt;i)&gt;=db)&#123;</span><br><span class="line">				res+=<span class="number">1</span>&lt;&lt;i;</span><br><span class="line">				da-=db&lt;&lt;i; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> sign?res:-res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://leetcode-cn.com/problems/xoh6Oh">题目链接</a></h1>]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>P1908 逆序对</title>
    <url>/2022/01/05/mergesort2//</url>
    <content><![CDATA[<p><img src="https://i.bmp.ovh/imgs/2022/01/e36c2e67ce76d320.png"></p>
<p><strong>题目描述</strong><br>猫猫 TOM 和小老鼠 JERRY 最近又较量上了，但是毕竟都是成年人，他们已经不喜欢再玩那种你追我赶的游戏，现在他们喜欢玩统计。</p>
<p>最近，TOM 老猫查阅到一个人类称之为“逆序对”的东西，这东西是这样定义的：对于给定的一段正整数序列，逆序对就是序列中 a_i&gt;a_ja<br>i<br>​&gt;a<br>j<br>​<br>  且 i&lt;ji&lt;j 的有序对。知道这概念后，他们就比赛谁先算出给定的一段正整数序列中逆序对的数目。注意序列中可能有重复数字。</p>
<p><strong>Update:数据已加强。</strong></p>
<p><strong>输入格式</strong><br>第一行，一个数 nn，表示序列中有 nn个数。</p>
<p>第二行 nn 个数，表示给定的序列。序列中每个数字不超过 10^910<br>9<br> 。</p>
<p><strong>输出格式</strong><br>输出序列中逆序对的数目。</p>
<p><strong>输入输出样例</strong><br><strong>输入</strong><br>6<br>5 4 2 6 3 1<br><strong>输出</strong><br>11<br><strong>说明/提示</strong><br>对于 25%25% 的数据，n \leq 2500n≤2500</p>
<p>对于 50%50% 的数据，n \leq 4 \times 10^4n≤4×10<br>4<br> 。</p>
<p>对于所有数据，n \leq 5 \times 10^5n≤5×10<br>5</p>
<p>请使用较快的输入输出</p>
<p>应该不会 O(n^2)O(n<br>2<br> ) 过 50 万吧 by chen_zhe</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">500010</span>;</span><br><span class="line"><span class="keyword">int</span> q[N],n;</span><br><span class="line"><span class="keyword">int</span> s[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans =<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)    <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(l,mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">int</span> i=l;</span><br><span class="line">    <span class="keyword">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k=l;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i]&lt;=q[j])&#123;   </span><br><span class="line">            s[k++]=q[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            s[k++]=q[j++];</span><br><span class="line">            ans+=mid-i+<span class="number">1</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)   s[k++]=q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) s[k++]=q[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memcpy</span>(q+l,s+l,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*(r-l+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)    cin &gt;&gt;q[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge_sort</span>(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt;ans &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2022/01/05/mergesort//</url>
    <content><![CDATA[<p><img src="https://i.bmp.ovh/imgs/2022/01/d69e487339a6b8cc.png"><br>给定你一个长度为 n 的整数数列。</p>
<p>请你使用归并排序对这个数列按照从小到大进行排序。</p>
<p>并将排好序的数列按顺序输出。</p>
<p>输入格式<br>输入共两行，第一行包含整数 n。</p>
<p>第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整个数列。</p>
<p>输出格式<br>输出共一行，包含 n 个整数，表示排好序的数列。</p>
<p>数据范围<br>1≤n≤100000<br>输入样例：<br>5<br>3 1 2 4 5<br>输出样例：<br>1 2 3 4 5</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> q[N],n;</span><br><span class="line"><span class="keyword">int</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)    <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(l,mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">int</span> i=l;</span><br><span class="line">    <span class="keyword">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k=l;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i]&lt;q[j])   s[k++]=q[i++];</span><br><span class="line">        <span class="keyword">else</span>    s[k++]=q[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)   s[k++]=q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) s[k++]=q[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memcpy</span>(q+l,s+l,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*(r-l+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)    cin &gt;&gt;q[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge_sort</span>(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)    cout &lt;&lt; q[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer II 002. 二进制加法</title>
    <url>/2022/01/26/offer002//</url>
    <content><![CDATA[<p>给定两个 01 字符串 a 和 b ，请计算它们的和，并以二进制字符串的形式输出。</p>
<p>输入为 <strong>非空</strong> 字符串且只包含数字 1 和 0。</p>
<p> </p>
<p><strong>示例 1:</strong><br></p>
<blockquote>
<p><strong>输入:</strong> a = “11”, b = “10”<br><br><strong>输出:</strong> “101”<br></p>
</blockquote>
<p><strong>示例 2:</strong><br></p>
<blockquote>
<p><strong>输入:</strong> a = “1010”, b = “1011”<br><br><strong>输出:</strong> “10101”<br>
 </p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>每个字符串仅由字符 ‘0’ 或 ‘1’ 组成。</li>
<li>1 &lt;= a.length, b.length &lt;= 10^4</li>
<li>字符串如果不是 “0” ，就都不含前导零。</li>
</ul>
<p><strong>代码</strong><br></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">        string res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>() || i&lt;b.<span class="built_in">size</span>()||t;i++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(i &lt; a.<span class="built_in">size</span>()) t += (a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(i &lt; b.<span class="built_in">size</span>()) t += (b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            res += (t % <span class="number">2</span> % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            t /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<br>
# [题目链接](https://leetcode-cn.com/problems/JFETK5)

]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer II 004. 只出现一次的数字</title>
    <url>/2022/01/26/offer004//</url>
    <content><![CDATA[<p>给你一个整数数组 nums ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次</strong> 。请你找出并返回那个只出现了一次的元素。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入：</strong>nums = [2,2,3,2]<br><br><strong>输出：</strong>3<br></p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><strong>输入：</strong>nums = [0,1,0,1,0,1,100]<br><br><strong>输出：</strong>100<br>
 </p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= nums.length &lt;= 3 * 104</li>
<li>-231 &lt;= nums[i] &lt;= 231 - 1</li>
<li>nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)  b=~a&amp;(b^num),a=~b&amp;(a^num);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://leetcode-cn.com/problems/WGki4K/">题目链接</a></h1>]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>protobuf安装以及一些问题解决</title>
    <url>/2021/12/10/protobuf_install_error//</url>
    <content><![CDATA[<h1 id="protobuf安装以及一些问题"><a href="#protobuf安装以及一些问题" class="headerlink" title="protobuf安装以及一些问题"></a>protobuf安装以及一些问题</h1><p>— ↓按照以下命令执行↓ —</p>
<ol>
<li><ul>
<li><pre><code> sudo apt-get install git
</code></pre>
</li>
</ul>
</li>
<li><ul>
<li><pre><code> git clone https://github.com/protocolbuffers/protobuf.git 
</code></pre>
</li>
</ul>
</li>
<li><ul>
<li><pre><code>  cd protobuf 
</code></pre>
</li>
</ul>
</li>
<li><ul>
<li><pre><code>  git submodule update --init --recursive
</code></pre>
</li>
</ul>
</li>
<li><ul>
<li><pre><code>  ./autogen.sh 
</code></pre>
</li>
</ul>
</li>
<li><ul>
<li><pre><code>./configure 
</code></pre>
</li>
</ul>
</li>
<li><ul>
<li><pre><code>   make 
</code></pre>
</li>
</ul>
</li>
<li><ul>
<li><pre><code> make make check 
</code></pre>
</li>
</ul>
</li>
<li><ul>
<li><pre><code> sudo make install
</code></pre>
</li>
</ul>
</li>
<li><ul>
<li><pre><code> sudo ldconfig 
</code></pre>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="错误解决"><a href="#错误解决" class="headerlink" title="错误解决"></a>错误解决</h2><p><strong>下载protobuf报错 443 或者 其余端口</strong><br>解决方法: 换手机热点进行下载，科学上网进行下载， 多试几次。</p>
<p><strong>初始化git报错</strong><br>解决方法: 先执行git init 在执行git submodule update –init –recursive</p>
<p><strong>执行 make check报错</strong><br>报错1.<img src="https://s3.bmp.ovh/imgs/2021/12/f7d33fb641a93964.png"></p>
<p><strong>解决方法： 在虚拟机-&gt;编辑虚拟机设置-&gt;内存更改为8GB即可解决</strong><br><img src="https://i.bmp.ovh/imgs/2021/12/97020a34bf5174f3.png"></p>
<p>成功图片:<br><img src="https://i.bmp.ovh/imgs/2021/12/4ed7a8d0a9bb5d24.png"><br><strong>错误2：</strong><br><img src="https://i.bmp.ovh/imgs/2021/12/c3856418982c87d8.png"><br>解决方案: 暂无，这个并不会影响生成的.h和.cc文件</p>
<hr>
<p><strong>安装完成后将代码写好 后缀名为.proto文件.</strong><br><strong>执行:</strong><br><strong>protoc -I=./ –cpp_out=./ 文件名.proto</strong><br>之后就会生成.h和.cc文件<br><img src="https://i.bmp.ovh/imgs/2021/12/2ad5e05878b07e89.png"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer II 003. 前 n 个数字二进制中 1 的个数</title>
    <url>/2022/01/26/offer003//</url>
    <content><![CDATA[<p>给定一个非负整数 n ，请计算 0 到 n 之间的每个数字的二进制表示中 1 的个数，并输出一个数组。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p><strong>输入:</strong> n = 2<br><br><strong>输出:</strong> [0,1,1]<br><br><strong>解释:</strong> <br><br>0 –&gt; 0<br><br>1 –&gt; 1<br><br>2 –&gt; 10<br></p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p><strong>输入:</strong> n = 5<br><br><strong>输出:</strong> [0,1,1,2,1,2]<br><br><strong>解释:</strong><br><br>0 –&gt; 0<br><br>1 –&gt; 1<br><br>2 –&gt; 10<br><br>3 –&gt; 11<br><br>4 –&gt; 100<br><br>5 –&gt; 101<br>
 </p>
</blockquote>
<p><strong>说明 :</strong></p>
<ul>
<li>0 &lt;= n &lt;= 105
 </li>
</ul>
<p><strong>进阶:</strong></p>
<ul>
<li>给出时间复杂度为 O(n*sizeof(integer)) 的解答非常容易。但你可以在线性时间 O(n) 内用一趟扫描做到吗？</li>
<li>要求算法的空间复杂度为 O(n) 。</li>
<li>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount ）来执行此操作。</li>
</ul>
<p><strong>代码</strong><br></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)   dp[i]=(i&amp;<span class="number">1</span>)+dp[i&gt;&gt;<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://leetcode-cn.com/problems/w3tCBm/">题目链接</a></h1>]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>sort求第k小的数</title>
    <url>/2022/01/05/sort2//</url>
    <content><![CDATA[<p><img src="https://i.bmp.ovh/imgs/2022/01/70c19c413d312378.png"><br>题目描述<br>输入 nn（1 \le n &lt; 50000001≤n&lt;5000000 且 nn 为奇数）个数字 a_ia<br>i<br>​<br> （1 \le a_i &lt; {10}^91≤a<br>i<br>​<br> &lt;10<br>9<br> ），输出这些数字的第 kk 小的数。最小的数是第 00 小。</p>
<p>请尽量不要使用 nth_element 来写本题，因为本题的重点在于练习分治算法。</p>
<p>输入格式<br>无</p>
<p>输出格式<br>无</p>
<p>输入输出样例<br>输入 #1复制<br>5 1<br>4 3 2 1 5<br>输出 #1复制<br>2</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> q[N],n;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i=l<span class="number">-1</span>, j=r+<span class="number">1</span>,val = q[l+r&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i]&lt;val);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j]&gt;val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) <span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(k&lt;=j)</span><br><span class="line">        <span class="built_in">quick_sort</span>(l,j);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">quick_sort</span>(j+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;q[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">quick_sort</span>(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; q[k] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2022/01/05/sort//</url>
    <content><![CDATA[<p><img src="https://i.bmp.ovh/imgs/2022/01/e89e1d4856450600.png"><br>题目描述<br>利用快速排序算法将读入的 NN 个数从小到大排序后输出。</p>
<p>快速排序是信息学竞赛的必备算法之一。对于快速排序不是很了解的同学可以自行上网查询相关资料，掌握后独立完成。（C++ 选手请不要试图使用 STL，虽然你可以使用 sort 一遍过，但是你并没有掌握快速排序算法的精髓。）</p>
<p>输入格式<br>第 11 行为一个正整数 NN，第 22 行包含 NN 个空格隔开的正整数 a_ia<br>i<br>​<br> ，为你需要进行排序的数，数据保证了 A_iA<br>i<br>​<br>  不超过 10^910<br>9<br> 。</p>
<p>输出格式<br>将给定的 NN 个数从小到大输出，数之间空格隔开，行末换行且无空格。</p>
<p>输入输出样例<br>输入<br>5<br>4 2 4 5 1</p>
<p>输出<br>1 2 4 4 5</p>
<p>说明/提示<br>对于 20%20% 的数据，有 N\leq 10^3N≤10<br>3；<br>对于 100%100% 的数据，有 N\leq 10^5N≤10<br>5。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> q[N],n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)    <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> i=l<span class="number">-1</span>,j=r+<span class="number">1</span>,val=q[l+r&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++;<span class="keyword">while</span>(q[i]&lt;val);</span><br><span class="line">        <span class="keyword">do</span> j--;<span class="keyword">while</span>(q[j]&gt;val);</span><br><span class="line">    <span class="keyword">if</span>(i&lt;j) <span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">quick_sort</span>(l,j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(j+<span class="number">1</span>,r);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;q[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">quick_sort</span>(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cout&lt;&lt;q[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>静态双链表</title>
    <url>/2022/01/08/staticdoubleList//</url>
    <content><![CDATA[<p>实现一个双链表，双链表初始为空，支持 5 种操作：</p>
<ol>
<li>在最左侧插入一个数；</li>
<li>在最右侧插入一个数；</li>
<li>将第 k 个插入的数删除；</li>
<li>在第 k 个插入的数左侧插入一个数；</li>
<li>在第 k 个插入的数右侧插入一个数</li>
<li>现在要对该链表进行 <strong>M</strong> 次操作，进行完所有操作后，从左到右输出整个链表。</li>
</ol>
<p><strong>注意:</strong> 题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。</p>
<p><strong>输入格式</strong><br>第一行包含整数 <strong>M</strong>，表示操作次数。</p>
<p>接下来 <strong>M</strong> 行，每行包含一个操作命令，操作命令可能为以下几种：</p>
<ol>
<li>L x，表示在链表的最左端插入数 x。</li>
<li>R x，表示在链表的最右端插入数 x。</li>
<li>D k，表示将第 k 个插入的数删除。</li>
<li>IL k x，表示在第 k 个插入的数左侧插入一个数。</li>
<li>IR k x，表示在第 k 个插入的数右侧插入一个数。</li>
</ol>
<p><strong>输出格式</strong><br>共一行，将整个链表从左到右输出。</p>
<p><strong>数据范围</strong><br>1≤M≤100000<br>所有操作保证合法。</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>10<br>R 7<br>D 1<br>L 3<br>IL 2 10<br>D 3<br>IL 2 7<br>L 8<br>R 9<br>IL 4 7<br>IR 2 2</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>8 7 7 3 2 9</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> e[N],r[N],l[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    l[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    idx=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=x,r[idx]=r[k],l[idx]=k,l[r[k]]=idx,r[k]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[l[k]]=r[k];</span><br><span class="line">    l[r[k]]=l[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">       string c;</span><br><span class="line">       cin&gt;&gt;c;</span><br><span class="line">       <span class="keyword">if</span>(c==<span class="string">&quot;L&quot;</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> x;</span><br><span class="line">           cin&gt;&gt;x;</span><br><span class="line">           </span><br><span class="line">           <span class="built_in">push</span>(<span class="number">0</span>,x);</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&quot;R&quot;</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> x;</span><br><span class="line">           cin&gt;&gt;x;</span><br><span class="line">           <span class="built_in">push</span>(l[<span class="number">1</span>],x);</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&quot;D&quot;</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> k;</span><br><span class="line">           cin&gt;&gt;k;</span><br><span class="line">           <span class="built_in">del</span>(k+<span class="number">1</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&quot;IR&quot;</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> k,x;</span><br><span class="line">           cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line">           <span class="built_in">push</span>(k+<span class="number">1</span>,x);</span><br><span class="line">       &#125;<span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> k,x;</span><br><span class="line">           cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line">           <span class="built_in">push</span>(l[k+<span class="number">1</span>],x);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=r[<span class="number">0</span>];i!=<span class="number">1</span>;i=r[i])</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;e[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>表达式求值</title>
    <url>/2022/01/08/value//</url>
    <content><![CDATA[<p>给定一个表达式，其中运算符仅包含 +,-,*,/（加 减 乘 整除），可能包含括号，请你求出表达式的最终值。</p>
<p><strong>注意：</strong></p>
<ul>
<li>数据保证给定的表达式合法。</li>
<li>题目保证符号 - 只作为减号出现，不会作为负号出现，例如，-1+2,(2+2)*(-(1+1)+2) 之类表达式均不会出现。</li>
<li>题目保证表达式中所有数字均为正整数。</li>
<li>题目保证表达式在中间计算过程以及结果中，均不超过 231−1。</li>
<li>题目中的整除是指向 0 取整，也就是说对于大于 0 的结果向下取整，例如 5/3=1，对于小于 0 的结果向上取整，例如 5/(1−4)=−1。</li>
<li>C++和Java中的整除默认是向零取整；Python中的整除//默认向下取整，因此Python的eval()函数中的整除也是向下取整，在本题中不能直接使用。</li>
</ul>
<p><strong>输入格式</strong><br>共一行，为给定表达式。</p>
<p><strong>输出格式</strong><br>共一行，为表达式的结果。</p>
<p><strong>数据范围</strong><br>表达式的长度不超过(\10^5)</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>(2+2)*(1+1)</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>8</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">stack&lt;<span class="keyword">char</span>&gt; op;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; pr=&#123;&#123;<span class="string">&#x27;+&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;-&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;*&#x27;</span>,<span class="number">2</span>&#125;,&#123;<span class="string">&#x27;/&#x27;</span>,<span class="number">2</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b=num.<span class="built_in">top</span>();num.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">int</span> a=num.<span class="built_in">top</span>();num.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">char</span> c=op.<span class="built_in">top</span>();op.<span class="built_in">pop</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(c)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:   s=a+b; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:   s=a-b; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:   s=a*b; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:   s=a/b; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    num.<span class="built_in">push</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> c=str[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c))&#123;</span><br><span class="line">            <span class="keyword">int</span> j,n=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(j=i;j&lt;str.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(str[j]);j++)&#123;</span><br><span class="line">                n=n*<span class="number">10</span>+(str[j]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            num.<span class="built_in">push</span>(n);</span><br><span class="line">            i=j<span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;(&#x27;</span>)op.<span class="built_in">push</span>(c);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(op.<span class="built_in">size</span>() &amp;&amp; op.<span class="built_in">top</span>()!=<span class="string">&#x27;(&#x27;</span>) <span class="built_in">eval</span>();</span><br><span class="line">            op.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(op.<span class="built_in">size</span>() &amp;&amp; pr[op.<span class="built_in">top</span>()]&gt;=pr[c]) <span class="built_in">eval</span>();</span><br><span class="line">            op.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(op.<span class="built_in">size</span>()) <span class="built_in">eval</span>();</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; num.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
