<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Space">


    <meta name="subtitle" content=" ">




<title>线程 | Space Blog</title>



    <link rel="icon" href="/favico.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.0.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Space Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Space Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">线程</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Space</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">二月 10, 2022&nbsp;&nbsp;0:00:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Linux/">Linux</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h1><blockquote>
<p>线程，是进程内部的一个控制序列。<br><br>即使不使用线程，进程内部也有一个执行线程。<br><br><br><br><strong>类比</strong>：创建一个进程，类似于“克隆”一个家庭。<br>该“家庭”与原来的家庭完全相同<br>但是新“家庭”和原来的家庭完全独立。<br>进程包含一个或多个线程，类似于一个家庭包含一个或多个家庭成员。<br><br> 家庭内的各成员同时做各自的事情（父亲工作、母亲持家、小孩上学）<br>而对于家庭外部的人来说，这个家庭同时在做多件事情。<br>家庭内的每个成员，就是一个线程。<br>各个家庭成员有自己的个人资源（线程有自己的局部变量）<br>但是所有家庭成员都能共享这个家庭的资源:房子、汽车、家庭的公共资金。<br>（同一个进程内的各个线程，能够共享整个进程的全局变量，除了线程的局部变量外，其他资源都共享）</p>
</blockquote>
<p><code>注意：单核处理器上，同一个时刻只能运行一个线程。</code><br><code>但是对于用户而言，感觉如同同时执行了多个线程一样</code><br><code>（各线程在单核CPU上切换，在一段时间内，同时执行了多个线程）</code></p>
<hr>
<h1 id="为什么使用线程"><a href="#为什么使用线程" class="headerlink" title="为什么使用线程"></a>为什么使用线程</h1><blockquote>
<ul>
<li><strong>使用fork创建进程以执行新的任务，该方式的代价很高。</strong></li>
</ul>
</blockquote>
<ul>
<li><strong>多个进程间不会直接共享内存</strong></li>
<li><strong>线程是进程的基本执行单元，一个进程的所有任务都在线程中执行，进程要想执行任务，必须得有线程，进程至少要有一条线程，程序启动会默认开启一条线程，这条线程被称为主线程或 UI 线程</strong></li>
</ul>
<hr>
<h1 id="线程的优点与缺点"><a href="#线程的优点与缺点" class="headerlink" title="线程的优点与缺点"></a>线程的优点与缺点</h1><blockquote>
<p><strong>优点:</strong> <strong>创建线程比创建进程，开销要小。</strong><br><br><br><strong>缺点:<br></strong></p>
</blockquote>
<ol>
<li><strong>多线程编程，需特别小心，很容易发生错误。</strong><br></li>
<li><strong>多线程调试很困难。</strong><br></li>
<li><strong>把一个任务划分为两部分，用两个线程在单处理器上运行时，不一定更快。除非能确定这两个部分能同时执行、且运行在多处理器上。</strong><br></li>
</ol>
<hr>
<h1 id="线程的应用场合"><a href="#线程的应用场合" class="headerlink" title="线程的应用场合"></a>线程的应用场合</h1><blockquote>
<ol>
<li><strong>需要让用户感觉在同时做多件事情时，比如，处理文档的进程，一个线程处理用户编辑，一个线程同时统计用户的字数.</strong><br></li>
<li><strong>当一个应用程序，需要同时处理输入、计算、输出时，可开3个线程，分别处理输入、计算、输出。让用户感觉不到等待。</strong><br></li>
<li><strong>高并发编程。</strong><br></li>
</ol>
</blockquote>
<hr>
<h1 id="线程的使用"><a href="#线程的使用" class="headerlink" title="线程的使用"></a>线程的使用</h1><h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><pre><code>pthread_create
</code></pre>
<p>原型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">pthread_create</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">pthread_t</span> *thread,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">void</span> *(*start_routine)(<span class="keyword">void</span>*), </span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">void</span> *arg)</span></span>;         </span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数：<strong>thread</strong>, 指向新线程的标识符。<br><br>           通过该指针返回所创建线程的标识符。<br><br>          <strong>attr</strong>, 用来设置新线程的属性。<br><br>           一般取默认属性，<strong>即该参数取NULL</strong><br><br>           <strong>start_routine</strong>, 该线程的处理函数<br><br>           该函数的返回类型和参数类型都是<strong>void</strong> *<strong>arg</strong>, 线程处理函数 <strong>start_routine</strong> 的参数<br><br><br><strong>功能</strong>：创建一个新线程，同时指定该线程的属性、执行函数、执行函数的参数通过参数1返回该线程的标识符。<br><br><br><strong>返回值</strong>：成功，返回0<br>   失败，返回错误代码<br><strong>注意：大部分pthread_开头的函数成功时返回0，失败时返回错误码（而不是-1）</strong><br><strong>注意：使用fork创建进程后，进程马上就启动，但是是和父进程同时执行fork后的代码。</strong><br><br><strong>使用pthread_create创建线程后，新线程马上就启动，即执行对应的线程处理函数。</strong></p>
</blockquote>
<hr>
<h2 id="线程的终止"><a href="#线程的终止" class="headerlink" title="线程的终止"></a>线程的终止</h2><pre><code>pthread_exit
</code></pre>
<p>原型:<br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">pthread_exit</span> <span class="params">(<span class="keyword">void</span> *retval)</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>功能：在线程函数内部调用该函数。<br><br>终止该线程，并通过参数retval返回一个指针。<br><br>该指针不能指向该线程的局部变量。<br></p>
</blockquote>
<hr>
<h2 id="等待线程的结束"><a href="#等待线程的结束" class="headerlink" title="等待线程的结束"></a>等待线程的结束</h2><pre><code>pthread_join
</code></pre>
<p>原型:<br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">pthread_join</span>  <span class="params">(<span class="keyword">pthread_t</span> th,<span class="keyword">void</span> **thread_return)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数：<strong>th</strong>,  指定等待的线程 <strong>thread_return</strong>, 指向该线程函数的返回值,线程函数的返回值类型为** void* ** ，故该参数的类型为<strong>void</strong>**<br><br>功能：类似与进程中的 <strong>waitpid</strong>等待指定的线程结束，并使参数指向该线程函数的返回值（用 <strong>pthread_exit</strong> 返回的值）</p>
</blockquote>
<hr>
<h2 id="线程的编译"><a href="#线程的编译" class="headerlink" title="线程的编译"></a>线程的编译</h2><blockquote>
<ol>
<li><strong>编译时，定义宏_REENTRANT</strong><br><pre><code> 即:**gcc -D_REENTRANT (#define REENTRANT)**
</code></pre>
<br>
    **功能**：告诉编译器，编译时需要可重入功能.
            即使得，在编译时，编译部分函数的可重入版本.
<br></li>
</ol>
<p><strong>注：在单线程程序中，整个程序都是顺序执行的，一个函数在同一时刻只能被一个函数调用，但在多线程中，由于并发性，一个函数可能同时被多个函数调用，此时这个函数就成了临界资源，很容易造成调用函数处理结果的相互影响，如果一个函数在多线程并发的环境中每次被调用产生的结果是不确定的，我们就说这个函数是”不可重入的”/“线程不安全”的。</strong><br><br><br><br>2. <strong>编译时</strong>，指定线程库<br><br>       即: <strong>gcc -lpthread</strong><br><br>        功能：使用系统默认的<strong>NPTL</strong>线程库,<br>               即在默认路径中寻找库文件<strong>libpthread.so</strong><br>               默认路径为**/usr/lib<strong>和</strong>/usr/local/lib**<br><br><br><br>   当系统默认使用的不是<strong>NPTL</strong>线程库时（系统较老，2003年以前）<br>       指定：<strong>gcc  -L/usr/lib/nptl   -lpthread</strong><br>       补充： <strong>-L</strong> 指定库文件所在的目录<br>               <strong>-l</strong> 指定库文件的名称(<strong>-lpthread</strong> ,指库文件名为<strong>libpthread.so</strong>)<br>        <br><br>   总结：一般使用如下形式即可<strong>gcc   -D_REENTRANT   -lpthread    mythread.c    -o   mythread</strong></p>
</blockquote>
<p><strong>例:</strong><br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> my_global;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">my_thread_handle</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">	val = *((<span class="keyword">int</span>*)arg);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;new thread begin, arg=%d\n&quot;</span>, val);</span><br><span class="line">	my_global += val;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">	<span class="comment">//线程结束</span></span><br><span class="line">	<span class="built_in">pthread_exit</span>(&amp;my_global);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  不再执行</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;new thread end\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span>  mythread;</span><br><span class="line">	<span class="keyword">int</span> arg;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="keyword">void</span> *thread_return;</span><br><span class="line"></span><br><span class="line">	arg = <span class="number">100</span>;</span><br><span class="line">	my_global = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;my_global=%d\n&quot;</span>, my_global);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ready create thread...\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	ret = <span class="built_in">pthread_create</span>(&amp;mythread, <span class="number">0</span>, my_thread_handle, &amp;arg);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;create thread failed!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;wait thread finished...\n&quot;</span>);</span><br><span class="line">	ret = <span class="built_in">pthread_join</span>(mythread, &amp;thread_return);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;pthread_join failed!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;wait thread end, return value is %d\n&quot;</span>, *((<span class="keyword">int</span>*)thread_return));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;my_global=%d\n&quot;</span>, my_global);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;create thread finished!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h1><ol>
<li><code>线程的互斥</code> - 指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</li>
<li><code>线程的同步</code> - 指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问.</li>
</ol>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><blockquote>
<p>同一个进程内的各个线程，共享该进程内的<strong>全局变量</strong><br><br>如果多个线程同时对某个全局变量进行访问时，就可能导致竞态。<br><br><br><strong>解决办法:</strong> 对临界区使用信号量、或者互斥量</p>
</blockquote>
<h4 id="信号量和互斥量的选择"><a href="#信号量和互斥量的选择" class="headerlink" title="信号量和互斥量的选择"></a>信号量和互斥量的选择</h4><blockquote>
<p>对于同步和互斥，使用信号量或互斥量都可以实现。<br><br>使用时，选择更符合语义的手段：<br><br>  如果要求最多只允许一个线程进入临界区，则使用互斥量<br><br>  如果要求多个线程之间的执行顺序满足某个约束，则使用信号量<br></p>
</blockquote>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><blockquote>
<p>什么是信号量<br><br> 此时所指的“信号量”是指用于同一个进程内多个线程之间的信号量。<br> 即<strong>POSIX</strong>信号量，而不是<strong>System V</strong>信号量（用于进程之间的同步)<br><br><br> 用于线程的信号量的原理，与用于进程之间的信号量的原理相同。<br> 都有<strong>P</strong>操作、<strong>V</strong>操作。<br><br> 信号量的表示：<strong>sem_t</strong>  类型</p>
</blockquote>
<h3 id="信号量初始化"><a href="#信号量初始化" class="headerlink" title="信号量初始化"></a>信号量初始化</h3><p><code>sem_init</code><br><strong>原型</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span>  *sem，<span class="keyword">int</span>  pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>功能</strong>：对信号量进行初始化<br><br> <strong>参数</strong>：<br>sem,  指向被初始化的信号量<br><br>  pshared, 0：表示该信号量是该进程内使用的“<strong>局部信号量</strong>”， 不再被其它进程共享。非0：该信号量可被其他进程共享，<strong>Linux</strong>不支持这种信号量<br><br>     <strong>value</strong>,  信号量的初值。&gt;= 0<br><br>    <strong>返回值</strong>：成功，返回0<br>                    失败， 返回错误码</p>
</blockquote>
<h3 id="信号量的P操作"><a href="#信号量的P操作" class="headerlink" title="信号量的P操作"></a>信号量的P操作</h3><p><code>sem_wait</code><br><strong>原型:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>返回值:成功,返回0<br><br>失败  :返回错误代码</p>
</blockquote>
<h3 id="信号量的V操作"><a href="#信号量的V操作" class="headerlink" title="信号量的V操作"></a>信号量的V操作</h3><p><code>sem_post</code><br><strong>原型</strong>：<br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">sem_post</span> <span class="params">(<span class="keyword">sem_t</span>  *sem)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>返回值：成功，返回0<br><br>失败， 返回错误码</p>
</blockquote>
<h3 id="信号量的删除"><a href="#信号量的删除" class="headerlink" title="信号量的删除"></a>信号量的删除</h3><p><code>sem_destroy</code><br><strong>原型</strong>：<br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">sem_destroy</span> <span class="params">(<span class="keyword">sem_t</span>  *sem)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>返回值：成功，返回0<br><br>失败， 返回错误码</p>
</blockquote>
<p><strong>例:</strong></p>
<blockquote>
<p><strong>主线程循环输入字符串，把字符串存放到一个全局缓存中。<br> 新线程从全局缓存中读取字符串，统计该字符串的长度。<br>直到用户输入end</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_SIZE 80</span></span><br><span class="line"><span class="comment">//信号量以及共享地址必须是全局变量</span></span><br><span class="line"><span class="keyword">char</span> buff[BUFF_SIZE];</span><br><span class="line"><span class="keyword">sem_t</span> sem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">str_thread_handle</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//P(sem)</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">sem_wait</span>(&amp;sem) != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;sem_wait failed!\n&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;string is: %slen=%d\n&quot;</span>, buff, <span class="built_in">strlen</span>(buff));</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strncmp</span>(buff, <span class="string">&quot;end&quot;</span>, <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="keyword">pthread_t</span>  str_thread;</span><br><span class="line">	<span class="keyword">void</span> *thread_return;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">sem_init</span>(&amp;sem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;sem_init failed!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">pthread_create</span>(&amp;str_thread, <span class="number">0</span>, str_thread_handle, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">fgets</span>(buff, <span class="built_in"><span class="keyword">sizeof</span></span>(buff), stdin);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//V(sem)</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">sem_post</span>(&amp;sem) != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;sem_post failed!\n&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strncmp</span>(buff, <span class="string">&quot;end&quot;</span>, <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">pthread_join</span>(str_thread, &amp;thread_return);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;pthread_join failed!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">sem_destroy</span>(&amp;sem);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;sem_destroy failed!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h1><blockquote>
<p>什么是互斥量<br><br>效果上等同于初始值为 1 的信号量<br><br><br><strong>互斥量的使用:</strong> 类型为 <strong>pthread_mutex_t</strong></p>
</blockquote>
<h4 id="互斥量的初始化"><a href="#互斥量的初始化" class="headerlink" title="互斥量的初始化"></a>互斥量的初始化</h4><p><strong>pthread_mutex_init</strong><br><br><strong>原型:</strong><br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>参数:mutex</strong>，指被初始化的互斥量<br><br><strong>attr</strong>，指向互斥量的属性<br><br><strong>一般取默认属性（当一个线程已获取互斥量后，该线程再次获取该信号量，将导致死锁!)</strong></p>
</blockquote>
<h4 id="互斥量的获取"><a href="#互斥量的获取" class="headerlink" title="互斥量的获取"></a>互斥量的获取</h4><p><code>pthread_mutex_lock</code><br><strong>原型：</strong><br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">pthread_mutex_lock</span> <span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="互斥量的释放"><a href="#互斥量的释放" class="headerlink" title="互斥量的释放"></a>互斥量的释放</h4><p><code>pthread_mutex_unlock</code><br><strong>原型：</strong><br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">pthread_mutex_unlock</span> <span class="params">(<span class="keyword">pthread_mutex_t</span>  *mutex)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="互斥量的删除"><a href="#互斥量的删除" class="headerlink" title="互斥量的删除"></a>互斥量的删除</h4><p><code>pthread_mutex_destroy</code><br><strong>原型:</strong><br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">pthread_mutex_destroy</span> <span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>; </span><br></pre></td></tr></table></figure>
<p><strong>例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_SIZE 80</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_value = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span>  lock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">str_thread_handle</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">pthread_mutex_lock</span>(&amp;lock);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (global_value  &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// work</span></span><br><span class="line">			<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;soled ticket(%d) to ChildStation(%d)\n&quot;</span>,</span><br><span class="line">				global_value, i+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		global_value--;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">pthread_mutex_unlock</span>(&amp;lock);</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="keyword">pthread_t</span>  str_thread;</span><br><span class="line">	<span class="keyword">void</span> *thread_return;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">pthread_mutex_init</span>(&amp;lock, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;pthread_mutex_init failed!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">pthread_create</span>(&amp;str_thread, <span class="number">0</span>, str_thread_handle, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">pthread_mutex_lock</span>(&amp;lock);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (global_value  &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// work</span></span><br><span class="line">			<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;soled ticket(%d) to MainStation(%d)\n&quot;</span>,</span><br><span class="line">				global_value, i+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		global_value--;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">pthread_mutex_unlock</span>(&amp;lock);</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">pthread_join</span>(str_thread, &amp;thread_return);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;pthread_join failed!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">pthread_mutex_destroy</span>(&amp;lock);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;pthread_mutex_destroy failed!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线程条件变量"><a href="#线程条件变量" class="headerlink" title="线程条件变量"></a>线程条件变量</h1><blockquote>
<p>与互斥锁不同，条件变量是用来等待而不是用来上锁。条件变量用来自动阻塞1一个线程，直到某特殊情况发生为止。同很长条件变量和互斥锁同时使用。<br><br>条件变量使我们可以睡眠等待某种条件出现。条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待”条件变量的条件成立”而挂起；另一个线程使”条件成立”（给出条件成立信号）。<br><br>条件的检测是在互斥锁的保护下进行的。如果一个条件为假，一个线程自动阻塞，并释放等待状态改变的互斥锁。如果另一个线程改变了条件，它发信号给关联的条件变量，唤醒一个或多个等待它的线程，重新获得互斥锁，重新评价条件。如果两进程共享可读写的内存，条件变量可以被用来实现这两进程间的线程同步。<br></p>
</blockquote>
<h4 id="条件变量初始化"><a href="#条件变量初始化" class="headerlink" title="条件变量初始化"></a>条件变量初始化</h4><p><code>pthread_cond_init</code><br><strong>原型:</strong><br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *attr)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>参数:</strong> <strong>cond</strong> 条件变量指针<br><br><strong>attr</strong>    条件变量高级属性<br><br>可man查看 需要安装:<strong>apt-get install manpages-posix-dev</strong></p>
</blockquote>
<h4 id="唤醒一个等待线程"><a href="#唤醒一个等待线程" class="headerlink" title="唤醒一个等待线程"></a>唤醒一个等待线程</h4><p><code>pthread_cond_signal</code><br>通知条件变量,唤醒一个等待者<br><strong>原型：</strong><br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span> <span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数：<strong>cond</strong>,  条件变量指针</p>
</blockquote>
<h4 id="唤醒所有等待该条件变量的线程"><a href="#唤醒所有等待该条件变量的线程" class="headerlink" title="唤醒所有等待该条件变量的线程"></a>唤醒所有等待该条件变量的线程</h4><p><code>pthread_cond_broadcast</code><br>广播条件变量<br><strong>原型：</strong> <br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span> <span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数：<strong>cond</strong>,  条件变量指针</p>
</blockquote>
<h4 id="等待条件变量-超时被唤醒"><a href="#等待条件变量-超时被唤醒" class="headerlink" title="等待条件变量/超时被唤醒"></a>等待条件变量/超时被唤醒</h4><p><code>pthread_cond_timedwait</code><br>等待条件变量cond被唤醒,直到由一个信号或广播，或绝对时间 <strong>abstime</strong> 到  * 才唤醒该线程<br><br><strong>原型：</strong><br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span> <span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">const</span> struct timespec *abstime)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数：<strong>cond</strong>,  条件变量指针<br>      <strong>pthread_mutex_t * mutex</strong> 互斥量<br><br>      <strong>const struct timespec * abstime</strong> 等待被唤醒的绝对超时时间</p>
</blockquote>
<h4 id="等待条件变量被唤醒"><a href="#等待条件变量被唤醒" class="headerlink" title="等待条件变量被唤醒"></a>等待条件变量被唤醒</h4><p><code>pthread_cond_wait</code><br>等待条件变量cond被唤醒(由一个信号或者广播)<br><strong>原型：</strong> <br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span> <span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数：<strong>cond</strong>,  条件变量指针<br>      <strong>pthread_mutex_t * mutex</strong> 互斥量<br><br>常见错误码：  [<strong>EINVAL</strong>] <strong>cond或mutex无效</strong>,<br><br>[<strong>EINVAL</strong>] 同时等待不同的互斥量  <br><br>[<strong>EINVAL</strong>] 主调线程没有占有互斥量 <br></p>
</blockquote>
<h4 id="释放-销毁条件变量"><a href="#释放-销毁条件变量" class="headerlink" title="释放/销毁条件变量"></a>释放/销毁条件变量</h4><p><code>pthread_cond_destroy</code><br>待销毁的条件变量<br><strong>原型：</strong> <br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span> <span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数：cond,  条件变量指针</p>
</blockquote>
<p><strong>例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread1</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;thread1 is running\n&quot;</span>);</span><br><span class="line">		<span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;thread1 lock..\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;thread1 applied the condition\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;thread1 unlock..\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread2</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;thread2 is running\n&quot;</span>);</span><br><span class="line">		<span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;thread2 lock..\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;thread2 applied the condition\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;thread2 unlock..\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pthread_t</span> thid1, thid2;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;condition variable study!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">pthread_cond_init</span>(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">pthread_create</span>(&amp;thid1, <span class="literal">NULL</span>, (<span class="keyword">void</span> *)thread1, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">pthread_create</span>(&amp;thid2, <span class="literal">NULL</span>, (<span class="keyword">void</span> *)thread2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">pthread_cond_signal</span>(&amp;cond);</span><br><span class="line">       <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Space</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://spaceout.cn/2022/02/10/pthread/">https://spaceout.cn/2022/02/10/pthread/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span></span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span></span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Linux/"># Linux</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2022/02/07/MallocFree/">高并发传统方式的弊端以及解决方式</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span></a></span>
    </div>
</footer>

    </div>
</body>

</html>